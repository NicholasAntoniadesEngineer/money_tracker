<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Money Tracker - Home</title>
    <style>
/* ===== styles/main.css ===== */
/* ============================================================================
   MONEY TRACKER - MAIN STYLESHEET
   Imports all CSS modules in dependency order
   ============================================================================ */

/* Core Foundation */
@import url('variables.css');
@import url('reset.css');
@import url('typography.css');
@import url('layout.css');

/* Components */
@import url('components/navigation.css');
@import url('components/forms.css');
@import url('components/tables.css');
@import url('components/buttons.css');
@import url('components/cards.css');

/* Views */
@import url('views/landing.css');
@import url('views/monthly-budget.css');
@import url('views/overview.css');
@import url('views/pots.css');
@import url('views/settings.css');

/* Utilities & Responsive */
@import url('utilities.css');
@import url('responsive.css');
@import url('print.css');

</style>
    <link rel="icon" href="data:,">
</head>
<body class="landing-page">
    <!-- Header will be injected by Header.js -->

    <main class="landing-main overview-main" role="main">
        <section class="hero-section">
            <h2 class="hero-title">Financial Overview</h2>
        </section>

        <section class="summary-section" aria-labelledby="summary-heading">
            <div class="summary-grid">
                <div class="summary-card">
                    <div class="summary-card-title">Total Income:</div>
                    <div id="overall-income" class="summary-card-value">£0.00</div>
                </div>
                <div class="summary-card">
                    <div class="summary-card-title">Total Expenses:</div>
                    <div id="overall-expenses" class="summary-card-value">£0.00</div>
                </div>
                <div class="summary-card">
                    <div class="summary-card-title">Total Savings:</div>
                    <div id="overall-savings" class="summary-card-value">£0.00</div>
                </div>
                <div class="summary-card">
                    <div class="summary-card-title">Total Pots/Investments:</div>
                    <div id="overall-pots" class="summary-card-value">£0.00</div>
                </div>
            </div>
        </section>

        <section class="months-comparison-section form-section" aria-labelledby="months-comparison-heading">
            <h2 id="months-comparison-heading" class="section-title">Monthly Comparison</h2>
            <table class="data-table" id="months-comparison-table">
                <thead>
                    <tr>
                        <th>Month</th>
                        <th>Income</th>
                        <th>Fixed Costs</th>
                        <th>Variable Costs</th>
                        <th>Unplanned</th>
                        <th>Total Expenses</th>
                        <th>Pots</th>
                        <th>Savings</th>
                        <th class="delete-column-header"></th>
                    </tr>
                </thead>
                <tbody id="months-comparison-tbody">
                </tbody>
            </table>
        </section>
    </main>

    <footer class="main-footer" role="contentinfo">
        <p>&copy; 2025 Money Tracker. All data stored locally in your browser.</p>
    </footer>

    
    
    
    
    
    
    
    
    
    
    
    
    
<script>
// ===== models/StorageService.js =====
/**
 * Storage Service
 * Abstracted localStorage operations with error handling
 * @module models/StorageService
 */

const StorageService = {
    /**
     * Get value from localStorage
     * @param {string} key - Storage key
     * @returns {*} Parsed value or null
     */
    get(key) {
        try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : null;
        } catch (error) {
            console.error(`Error loading data for key ${key}:`, error);
            return null;
        }
    },

    /**
     * Set value in localStorage
     * @param {string} key - Storage key
     * @param {*} value - Value to store
     * @returns {boolean} Success status
     */
    set(key, value) {
        try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
        } catch (error) {
            console.error(`Error saving data for key ${key}:`, error);
            return false;
        }
    },

    /**
     * Remove value from localStorage
     * @param {string} key - Storage key
     * @returns {boolean} Success status
     */
    remove(key) {
        try {
            localStorage.removeItem(key);
            return true;
        } catch (error) {
            console.error(`Error removing data for key ${key}:`, error);
            return false;
        }
    },

    /**
     * Clear all localStorage
     * @returns {boolean} Success status
     */
    clear() {
        try {
            localStorage.clear();
            return true;
        } catch (error) {
            console.error('Error clearing localStorage:', error);
            return false;
        }
    }
};

if (typeof window !== 'undefined') {
    window.StorageService = StorageService;
}


// ===== models/MonthFactory.js =====
/**
 * Month Factory
 * Creates and manages month data structures
 * @module models/MonthFactory
 */

const MonthFactory = {
    /**
     * Generate a month key from year and month
     * @param {number} year - Year (e.g., 2025)
     * @param {number} month - Month (1-12)
     * @returns {string} Month key (e.g., "2025-11")
     */
    generateMonthKey(year, month) {
        if (!year || !month || month < 1 || month > 12) {
            throw new Error('Invalid year or month');
        }
        return `${year}-${String(month).padStart(2, '0')}`;
    },

    /**
     * Parse month key to year and month
     * @param {string} monthKey - Month key (e.g., "2025-11")
     * @returns {Object} Object with year and month
     */
    parseMonthKey(monthKey) {
        if (!monthKey || typeof monthKey !== 'string') {
            throw new Error('Invalid month key');
        }
        const parts = monthKey.split('-');
        if (parts.length !== 2) {
            throw new Error('Invalid month key format');
        }
        return {
            year: parseInt(parts[0], 10),
            month: parseInt(parts[1], 10)
        };
    },

    /**
     * Get month name from month number
     * @param {number} monthNumber - Month number (1-12)
     * @returns {string} Month name
     */
    getMonthName(monthNumber) {
        const monthNames = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];
        if (monthNumber < 1 || monthNumber > 12) {
            throw new Error('Invalid month number');
        }
        return monthNames[monthNumber - 1] || '';
    },

    /**
     * Create a new month with default structure
     * @param {number} year - Year
     * @param {number} month - Month (1-12)
     * @param {Object} settings - Settings object with defaults
     * @returns {Object} New month data object
     */
    createNewMonth(year, month, settings = {}) {
        if (!year || !month || month < 1 || month > 12) {
            throw new Error('Invalid year or month');
        }

        const monthKey = this.generateMonthKey(year, month);
        const monthName = this.getMonthName(month);

        const startDate = new Date(year, month - 1, 1);
        const endDate = new Date(year, month, 0);

        const defaultVariableCategories = settings.defaultVariableCategories || ['Food', 'Travel/Transport', 'Activities'];
        const variableCosts = defaultVariableCategories.map(category => ({
            category: category,
            estimatedAmount: 0,
            actualAmount: 0,
            comments: ''
        }));

        const newMonth = {
            key: monthKey,
            year: year,
            month: month,
            monthName: monthName,
            dateRange: {
                start: startDate.toISOString().split('T')[0],
                end: endDate.toISOString().split('T')[0]
            },
            weeklyBreakdown: [],
            fixedCosts: [],
            variableCosts: variableCosts,
            unplannedExpenses: [],
            incomeSources: [],
            pots: [],
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };

        return newMonth;
    },

    /**
     * Calculate number of weeks in a month
     * @param {number} year - Year
     * @param {number} month - Month (1-12)
     * @returns {Array} Array of week objects with start and end dates
     */
    calculateWeeksInMonth(year, month) {
        const weeks = [];
        const firstDay = new Date(year, month - 1, 1);
        const lastDay = new Date(year, month, 0);
        const daysInMonth = lastDay.getDate();
        
        const firstDayOfWeek = firstDay.getDay();
        const daysToMonday = firstDayOfWeek === 0 ? -6 : 1 - firstDayOfWeek;
        
        let weekStartDay = 1 + daysToMonday;
        let weekEndDay = weekStartDay + 6;
        
        if (weekStartDay < 1) {
            weekStartDay = 1;
        }
        
        while (weekStartDay <= daysInMonth) {
            if (weekEndDay > daysInMonth) {
                weekEndDay = daysInMonth;
            }
            
            weeks.push({
                startDate: weekStartDay,
                endDate: weekEndDay,
                startFullDate: new Date(year, month - 1, weekStartDay),
                endFullDate: new Date(year, month - 1, weekEndDay),
                weekNumber: weeks.length + 1
            });
            
            weekStartDay = weekEndDay + 1;
            weekEndDay = weekStartDay + 6;
        }
        
        return weeks;
    }
};

if (typeof window !== 'undefined') {
    window.MonthFactory = MonthFactory;
}


// ===== services/CalculationService.js =====
/**
 * Calculation Service
 * Pure functions for all financial calculations
 * @module services/CalculationService
 */

const CalculationService = {
    /**
     * Calculate totals for a month
     * @param {Object} monthData - The month data object
     * @returns {Object} Totals object with estimated and actual values
     */
    calculateMonthTotals(monthData) {
        if (!monthData) {
            throw new Error('Month data is required for calculation');
        }

        const totals = {
            fixedCosts: { estimated: 0, actual: 0 },
            variableCosts: { estimated: 0, actual: 0 },
            unplannedExpenses: { actual: 0 },
            income: { estimated: 0, actual: 0 },
            pots: { estimated: 0, actual: 0 },
            expenses: { estimated: 0, actual: 0 },
            savings: { estimated: 0, actual: 0 }
        };

        if (monthData.fixedCosts && Array.isArray(monthData.fixedCosts)) {
            monthData.fixedCosts.forEach(cost => {
                totals.fixedCosts.estimated += this.parseNumber(cost.estimatedAmount || 0);
                totals.fixedCosts.actual += this.parseNumber(cost.actualAmount || 0);
            });
        }

        if (monthData.variableCosts && Array.isArray(monthData.variableCosts)) {
            monthData.variableCosts.forEach(cost => {
                totals.variableCosts.estimated += this.parseNumber(cost.monthlyBudget || cost.estimatedAmount || 0);
                totals.variableCosts.actual += this.parseNumber(cost.actualSpent || cost.actualAmount || 0);
            });
        }

        if (monthData.unplannedExpenses && Array.isArray(monthData.unplannedExpenses)) {
            monthData.unplannedExpenses.forEach(expense => {
                totals.unplannedExpenses.actual += this.parseNumber(expense.amount || 0);
            });
        }

        if (monthData.incomeSources && Array.isArray(monthData.incomeSources)) {
            monthData.incomeSources.forEach(income => {
                totals.income.estimated += this.parseNumber(income.estimated || 0);
                totals.income.actual += this.parseNumber(income.actual || 0);
            });
        } else if (monthData.income) {
            totals.income.estimated = 
                this.parseNumber(monthData.income.nicholasIncome?.estimated || 0) +
                this.parseNumber(monthData.income.laraIncome?.estimated || 0) +
                this.parseNumber(monthData.income.otherIncome?.estimated || 0);
            
            totals.income.actual = 
                this.parseNumber(monthData.income.nicholasIncome?.actual || 0) +
                this.parseNumber(monthData.income.laraIncome?.actual || 0) +
                this.parseNumber(monthData.income.otherIncome?.actual || 0);
        }

        if (monthData.pots && Array.isArray(monthData.pots)) {
            monthData.pots.forEach(pot => {
                totals.pots.estimated += this.parseNumber(pot.estimatedAmount || 0);
                totals.pots.actual += this.parseNumber(pot.actualAmount || 0);
            });
        }

        totals.expenses.estimated = totals.fixedCosts.estimated + totals.variableCosts.estimated;
        totals.expenses.actual = totals.fixedCosts.actual + totals.variableCosts.actual + totals.unplannedExpenses.actual;

        totals.savings.estimated = totals.income.estimated - totals.expenses.estimated - totals.pots.estimated;
        totals.savings.actual = totals.income.actual - totals.expenses.actual - totals.pots.actual;

        return totals;
    },

    /**
     * Calculate week totals from weekly breakdown
     * @param {Array} weeklyBreakdown - Array of week objects
     * @returns {Object} Totals for estimate and actual
     */
    calculateWeekTotals(weeklyBreakdown) {
        if (!Array.isArray(weeklyBreakdown)) {
            return { estimate: 0, actual: 0 };
        }

        const totals = weeklyBreakdown.reduce((acc, week) => {
            acc.estimate += this.parseNumber(week.estimate || week.weeklyEstimate || 0);
            acc.actual += this.parseNumber(week.actual || 0);
            return acc;
        }, { estimate: 0, actual: 0 });

        return totals;
    },

    /**
     * Calculate trend for a specific metric across months
     * @param {Array<string>} monthKeys - Sorted array of month keys
     * @param {Object} allMonths - Object containing all month data
     * @param {string} type - Type of metric ('income', 'expenses', 'savings')
     * @returns {Object} Trend data with average, percentage, and direction
     */
    calculateTrend(monthKeys, allMonths, type) {
        if (!Array.isArray(monthKeys) || monthKeys.length < 2) {
            return { average: 0, percentage: 0, direction: '→ Stable' };
        }

        const values = monthKeys.map(key => {
            const monthData = allMonths[key];
            if (!monthData) return 0;
            
            const totals = this.calculateMonthTotals(monthData);
            switch(type) {
                case 'income': return totals.income.actual;
                case 'expenses': return totals.expenses.actual;
                case 'savings': return totals.savings.actual;
                default: return 0;
            }
        });

        const average = values.reduce((a, b) => a + b, 0) / values.length;
        
        const firstHalf = values.slice(0, Math.floor(values.length / 2));
        const secondHalf = values.slice(Math.floor(values.length / 2));
        
        const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
        const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
        
        const percentage = firstAvg !== 0 ? ((secondAvg - firstAvg) / Math.abs(firstAvg)) * 100 : 0;
        const direction = percentage > 0 ? '↑ Increasing' : percentage < 0 ? '↓ Decreasing' : '→ Stable';

        return { average, percentage, direction };
    },

    /**
     * Calculate savings amount
     * @param {number} income - Total income
     * @param {number} expenses - Total expenses
     * @param {number} pots - Total pots/investments
     * @returns {number} Savings amount
     */
    calculateSavings(income, expenses, pots) {
        return this.parseNumber(income) - this.parseNumber(expenses) - this.parseNumber(pots);
    },

    /**
     * Parse number safely, returning 0 for invalid values
     * @param {*} value - Value to parse
     * @returns {number} Parsed number or 0
     */
    parseNumber(value) {
        const parsed = parseFloat(value || 0);
        return isNaN(parsed) ? 0 : parsed;
    }
};

if (typeof window !== 'undefined') {
    window.CalculationService = CalculationService;
}


// ===== services/FormHandler.js =====
/**
 * Form Handler Service
 * Handles form input creation, validation, and data extraction
 * @module services/FormHandler
 */

const FormHandler = {
    /**
     * Create a text input element
     * @param {Object} options - Input options
     * @param {string} options.type - Input type (text, number, date, etc.)
     * @param {string} options.value - Initial value
     * @param {string} options.placeholder - Placeholder text
     * @param {string} options.className - CSS class name
     * @param {string} options.id - Element ID
     * @param {Function} options.onChange - Change event handler
     * @param {Object} options.attributes - Additional attributes
     * @returns {HTMLInputElement} Created input element
     */
    createInput({ type = 'text', value = '', placeholder = '', className = '', id = '', onChange = null, attributes = {} }) {
        const input = document.createElement('input');
        input.type = type;
        input.value = value || '';
        input.placeholder = placeholder;
        if (className) input.className = className;
        if (id) input.id = id;
        
        Object.entries(attributes).forEach(([key, val]) => {
            input.setAttribute(key, val);
        });

        if (onChange && typeof onChange === 'function') {
            input.addEventListener('input', onChange);
        }

        return input;
    },

    /**
     * Create a textarea element
     * @param {Object} options - Textarea options
     * @param {string} options.value - Initial value
     * @param {string} options.placeholder - Placeholder text
     * @param {string} options.className - CSS class name
     * @param {string} options.id - Element ID
     * @param {Function} options.onChange - Change event handler
     * @param {Object} options.attributes - Additional attributes
     * @returns {HTMLTextAreaElement} Created textarea element
     */
    createTextarea({ value = '', placeholder = '', className = '', id = '', onChange = null, attributes = {} }) {
        const textarea = document.createElement('textarea');
        textarea.value = value || '';
        textarea.placeholder = placeholder;
        if (className) textarea.className = className;
        if (id) textarea.id = id;
        
        Object.entries(attributes).forEach(([key, val]) => {
            textarea.setAttribute(key, val);
        });

        if (onChange && typeof onChange === 'function') {
            textarea.addEventListener('input', onChange);
        }

        return textarea;
    },

    /**
     * Create a select element with options
     * @param {Object} options - Select options
     * @param {Array} options.options - Array of {value, text} objects
     * @param {string} options.value - Selected value
     * @param {string} options.className - CSS class name
     * @param {string} options.id - Element ID
     * @param {Function} options.onChange - Change event handler
     * @param {Object} options.attributes - Additional attributes
     * @returns {HTMLSelectElement} Created select element
     */
    createSelect({ options = [], value = '', className = '', id = '', onChange = null, attributes = {} }) {
        const select = document.createElement('select');
        if (className) select.className = className;
        if (id) select.id = id;
        
        Object.entries(attributes).forEach(([key, val]) => {
            select.setAttribute(key, val);
        });

        options.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option.value || '';
            optionElement.textContent = option.text || option.label || '';
            if (option.value === value) {
                optionElement.selected = true;
            }
            select.appendChild(optionElement);
        });

        if (onChange && typeof onChange === 'function') {
            select.addEventListener('change', onChange);
        }

        return select;
    },

    /**
     * Create a date input element
     * @param {Object} options - Date input options
     * @param {string} options.value - Initial date value (YYYY-MM-DD)
     * @param {string} options.className - CSS class name
     * @param {string} options.id - Element ID
     * @param {Function} options.onChange - Change event handler
     * @param {Object} options.attributes - Additional attributes
     * @returns {HTMLInputElement} Created date input element
     */
    createDateInput({ value = '', className = '', id = '', onChange = null, attributes = {} }) {
        return this.createInput({
            type: 'date',
            value,
            className,
            id,
            onChange,
            attributes
        });
    },

    /**
     * Create a checkbox input element
     * @param {Object} options - Checkbox options
     * @param {boolean} options.checked - Initial checked state
     * @param {string} options.className - CSS class name
     * @param {string} options.id - Element ID
     * @param {Function} options.onChange - Change event handler
     * @param {Object} options.attributes - Additional attributes
     * @returns {HTMLInputElement} Created checkbox element
     */
    createCheckbox({ checked = false, className = '', id = '', onChange = null, attributes = {} }) {
        const checkbox = this.createInput({
            type: 'checkbox',
            className,
            id,
            onChange,
            attributes
        });
        checkbox.checked = checked;
        return checkbox;
    },

    /**
     * Get form data from a form element or container
     * @param {HTMLElement} formElement - Form or container element
     * @param {Object} fieldMappings - Optional field name mappings
     * @returns {Object} Form data object
     */
    getFormData(formElement, fieldMappings = {}) {
        if (!formElement) {
            throw new Error('Form element is required');
        }

        const formData = {};
        const inputs = formElement.querySelectorAll('input, select, textarea');

        inputs.forEach(input => {
            const fieldName = fieldMappings[input.name] || input.name || input.id;
            if (!fieldName) return;

            if (input.type === 'checkbox') {
                formData[fieldName] = input.checked;
            } else if (input.type === 'number') {
                formData[fieldName] = parseFloat(input.value) || 0;
            } else {
                formData[fieldName] = input.value || '';
            }
        });

        return formData;
    },

    /**
     * Validate form fields
     * @param {HTMLElement} formElement - Form element to validate
     * @param {Object} validationRules - Validation rules object
     * @returns {Object} Validation result with isValid and errors
     */
    validateForm(formElement, validationRules = {}) {
        if (!formElement) {
            return { isValid: false, errors: ['Form element is required'] };
        }

        const errors = [];
        const inputs = formElement.querySelectorAll('input, select, textarea');

        inputs.forEach(input => {
            const fieldName = input.name || input.id;
            if (!fieldName) return;

            const rules = validationRules[fieldName];
            if (!rules) return;

            const value = input.type === 'checkbox' ? input.checked : input.value;

            if (rules.required && !value) {
                errors.push(`${fieldName} is required`);
            }

            if (rules.min && parseFloat(value) < rules.min) {
                errors.push(`${fieldName} must be at least ${rules.min}`);
            }

            if (rules.max && parseFloat(value) > rules.max) {
                errors.push(`${fieldName} must be at most ${rules.max}`);
            }

            if (rules.pattern && !rules.pattern.test(value)) {
                errors.push(`${fieldName} format is invalid`);
            }
        });

        return {
            isValid: errors.length === 0,
            errors
        };
    },

    /**
     * Set form values from data object
     * @param {HTMLElement} formElement - Form element
     * @param {Object} data - Data object with field names as keys
     */
    setFormData(formElement, data) {
        if (!formElement || !data) {
            return;
        }

        Object.entries(data).forEach(([key, value]) => {
            const input = formElement.querySelector(`[name="${key}"], #${key}`);
            if (!input) return;

            if (input.type === 'checkbox') {
                input.checked = Boolean(value);
            } else {
                input.value = value || '';
            }
        });
    }
};

if (typeof window !== 'undefined') {
    window.FormHandler = FormHandler;
}


// ===== services/TableRenderer.js =====
/**
 * Table Renderer Service
 * Handles all table rendering and row creation logic
 * @module services/TableRenderer
 */

const TableRenderer = {
    /**
     * Render a complete table with header and body
     * @param {Object} options - Table rendering options
     * @param {HTMLElement} options.container - Container element to render table into
     * @param {Array} options.columns - Column definitions
     * @param {Array} options.data - Data rows
     * @param {Object} options.config - Table configuration
     * @returns {HTMLTableElement} Created table element
     */
    renderTable({ container, columns, data = [], config = {} }) {
        if (!container) {
            throw new Error('Container element is required');
        }

        const table = document.createElement('table');
        table.className = config.className || 'data-table';

        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        
        columns.forEach(column => {
            const th = document.createElement('th');
            th.textContent = column.header || column.label || '';
            if (column.className) th.className = column.className;
            if (column.width) th.style.width = column.width;
            headerRow.appendChild(th);
        });

        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        if (config.tbodyId) tbody.id = config.tbodyId;

        if (data.length === 0 && config.emptyMessage) {
            const emptyRow = document.createElement('tr');
            const emptyCell = document.createElement('td');
            emptyCell.colSpan = columns.length;
            emptyCell.textContent = config.emptyMessage;
            emptyCell.className = 'empty-message';
            emptyCell.style.textAlign = 'center';
            emptyRow.appendChild(emptyCell);
            tbody.appendChild(emptyRow);
        } else {
            data.forEach((rowData, index) => {
                const row = this.renderRow({ columns, rowData, rowIndex: index, config });
                tbody.appendChild(row);
            });
        }

        table.appendChild(tbody);

        if (config.showTotal && config.totalRowData) {
            const tfoot = document.createElement('tfoot');
            const totalRow = this.renderTotalRow({ columns, totalData: config.totalRowData, config });
            tfoot.appendChild(totalRow);
            table.appendChild(tfoot);
        }

        if (container.tagName === 'TBODY') {
            container.parentNode.replaceChild(tbody, container);
            return container.parentNode;
        } else {
            container.innerHTML = '';
            container.appendChild(table);
            return table;
        }
    },

    /**
     * Render a single table row
     * @param {Object} options - Row rendering options
     * @param {Array} options.columns - Column definitions
     * @param {Object} options.rowData - Row data object
     * @param {number} options.rowIndex - Row index
     * @param {Object} options.config - Row configuration
     * @returns {HTMLTableRowElement} Created row element
     */
    renderRow({ columns, rowData, rowIndex = 0, config = {} }) {
        const row = document.createElement('tr');
        if (config.rowClassName) {
            row.className = config.rowClassName;
        }
        if (config.rowId) {
            row.id = typeof config.rowId === 'function' ? config.rowId(rowData, rowIndex) : config.rowId;
        }

        columns.forEach((column, colIndex) => {
            const cell = document.createElement('td');
            
            if (column.render && typeof column.render === 'function') {
                const renderedContent = column.render(rowData, rowIndex, colIndex);
                if (renderedContent instanceof HTMLElement) {
                    cell.appendChild(renderedContent);
                } else {
                    cell.innerHTML = renderedContent;
                }
            } else if (column.field) {
                const value = this.getNestedValue(rowData, column.field);
                if (column.type === 'currency') {
                    cell.textContent = window.Formatters ? window.Formatters.formatCurrency(value || 0) : `£${(value || 0).toFixed(2)}`;
                } else if (column.type === 'date') {
                    cell.textContent = window.Formatters ? window.Formatters.formatDate(value) : value || '';
                } else if (column.type === 'boolean') {
                    cell.textContent = value ? '✓' : '';
                } else {
                    cell.textContent = value || '';
                }
            }

            if (column.cellClassName) {
                cell.className = column.cellClassName;
            }

            row.appendChild(cell);
        });

        return row;
    },

    /**
     * Render a total row
     * @param {Object} options - Total row options
     * @param {Array} options.columns - Column definitions
     * @param {Object} options.totalData - Total data object
     * @param {Object} options.config - Configuration
     * @returns {HTMLTableRowElement} Created total row
     */
    renderTotalRow({ columns, totalData = {}, config = {} }) {
        const row = document.createElement('tr');
        row.className = 'total-row';

        columns.forEach((column, index) => {
            const cell = document.createElement('td');
            
            if (index === 0) {
                cell.innerHTML = '<strong>TOTALS</strong>';
            } else if (column.totalField) {
                const value = this.getNestedValue(totalData, column.totalField);
                if (column.type === 'currency') {
                    cell.innerHTML = `<strong>${window.Formatters ? window.Formatters.formatCurrency(value || 0) : `£${(value || 0).toFixed(2)}`}</strong>`;
                } else {
                    cell.innerHTML = `<strong>${value || ''}</strong>`;
                }
            } else if (column.totalId) {
                cell.id = column.totalId;
            }

            row.appendChild(cell);
        });

        return row;
    },

    /**
     * Update table with new data
     * @param {HTMLElement} tbody - Table body element
     * @param {Array} data - New data array
     * @param {Array} columns - Column definitions
     * @param {Object} config - Configuration
     */
    updateTable(tbody, data, columns, config = {}) {
        if (!tbody) {
            throw new Error('Table body element is required');
        }

        tbody.innerHTML = '';

        if (data.length === 0 && config.emptyMessage) {
            const emptyRow = document.createElement('tr');
            const emptyCell = document.createElement('td');
            emptyCell.colSpan = columns.length;
            emptyCell.textContent = config.emptyMessage;
            emptyCell.className = 'empty-message';
            emptyCell.style.textAlign = 'center';
            emptyRow.appendChild(emptyCell);
            tbody.appendChild(emptyRow);
        } else {
            data.forEach((rowData, index) => {
                const row = this.renderRow({ columns, rowData, rowIndex: index, config });
                tbody.appendChild(row);
            });
        }
    },

    /**
     * Create an editable input cell
     * @param {Object} options - Input cell options
     * @param {string} options.type - Input type
     * @param {*} options.value - Initial value
     * @param {string} options.className - CSS class
     * @param {Function} options.onChange - Change handler
     * @param {Object} options.attributes - Additional attributes
     * @returns {HTMLElement} Input element
     */
    createInputCell({ type = 'text', value = '', className = '', onChange = null, attributes = {} }) {
        if (window.FormHandler) {
            return window.FormHandler.createInput({ type, value, className, onChange, attributes });
        }
        
        const input = document.createElement('input');
        input.type = type;
        input.value = value || '';
        if (className) input.className = className;
        Object.entries(attributes).forEach(([key, val]) => {
            input.setAttribute(key, val);
        });
        if (onChange) input.addEventListener('input', onChange);
        return input;
    },

    /**
     * Create an editable textarea cell
     * @param {Object} options - Textarea cell options
     * @param {string} options.value - Initial value
     * @param {string} options.className - CSS class
     * @param {Function} options.onChange - Change handler
     * @param {Object} options.attributes - Additional attributes
     * @returns {HTMLElement} Textarea element
     */
    createTextareaCell({ value = '', className = '', onChange = null, attributes = {} }) {
        if (window.FormHandler) {
            return window.FormHandler.createTextarea({ value, className, onChange, attributes });
        }
        
        const textarea = document.createElement('textarea');
        textarea.value = value || '';
        if (className) textarea.className = className;
        Object.entries(attributes).forEach(([key, val]) => {
            textarea.setAttribute(key, val);
        });
        if (onChange) textarea.addEventListener('input', onChange);
        return textarea;
    },

    /**
     * Create a select cell
     * @param {Object} options - Select cell options
     * @param {Array} options.options - Option array
     * @param {string} options.value - Selected value
     * @param {string} options.className - CSS class
     * @param {Function} options.onChange - Change handler
     * @returns {HTMLElement} Select element
     */
    createSelectCell({ options = [], value = '', className = '', onChange = null }) {
        if (window.FormHandler) {
            return window.FormHandler.createSelect({ options, value, className, onChange });
        }
        
        const select = document.createElement('select');
        if (className) select.className = className;
        options.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option.value || '';
            optionElement.textContent = option.text || option.label || '';
            if (option.value === value) optionElement.selected = true;
            select.appendChild(optionElement);
        });
        if (onChange) select.addEventListener('change', onChange);
        return select;
    },

    /**
     * Get nested value from object using dot notation
     * @param {Object} obj - Source object
     * @param {string} path - Dot notation path
     * @returns {*} Value at path
     */
    getNestedValue(obj, path) {
        if (!obj || !path) return null;
        return path.split('.').reduce((current, prop) => current?.[prop], obj);
    },

    /**
     * Create delete button cell
     * @param {Function} onDelete - Delete handler
     * @param {string} ariaLabel - ARIA label
     * @returns {HTMLElement} Delete button
     */
    createDeleteButton(onDelete, ariaLabel = 'Delete row') {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'delete-row-x';
        button.textContent = '×';
        button.setAttribute('aria-label', ariaLabel);
        if (onDelete) {
            button.addEventListener('click', onDelete);
        }
        return button;
    }
};

if (typeof window !== 'undefined') {
    window.TableRenderer = TableRenderer;
}


// ===== utils/formatters.js =====
/**
 * Utility Functions
 * Shared formatting and helper functions
 */

const Formatters = {
    /**
     * Get currency symbol from settings
     */
    getCurrencySymbol() {
        if (typeof window !== 'undefined' && window.DataManager) {
            const settings = DataManager.getSettings();
            if (settings && settings.currency) {
                return settings.currency;
            }
        }
        return '£'; // Default to £
    },

    /**
     * Format currency amount
     */
    formatCurrency(amount) {
        const currencySymbol = this.getCurrencySymbol();
        return currencySymbol + parseFloat(amount || 0).toFixed(2);
    },

    /**
     * Format date for display
     */
    formatDate(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        return date.toLocaleDateString();
    },

    /**
     * Parse number safely
     */
    parseNumber(value) {
        const parsed = parseFloat(value || 0);
        return isNaN(parsed) ? 0 : parsed;
    },

    /**
     * Validate year input
     */
    validateYear(year) {
        const yearNum = parseInt(year, 10);
        return !isNaN(yearNum) && yearNum >= 2000 && yearNum <= 2100;
    },

    /**
     * Validate month input
     */
    validateMonth(month) {
        const monthNum = parseInt(month, 10);
        return !isNaN(monthNum) && monthNum >= 1 && monthNum <= 12;
    }
};

// Make available globally
if (typeof window !== 'undefined') {
    window.Formatters = Formatters;
}



// ===== services/FileService.js =====
/**
 * File Service
 * Handles all file I/O operations
 * @module services/FileService
 */

const FileService = {
    MONTHS_DIR: '/data/months/',

    /**
     * Load a month from individual JSON file
     * @param {string} monthKey - Month key (e.g., "2025-11")
     * @returns {Promise<Object|null>} Month data or null if not found
     */
    async loadMonthFromFile(monthKey) {
        try {
            if (window.location.protocol === 'file:') {
                console.log(`Using file:// protocol - cannot load ${monthKey}.json directly.`);
                console.log('Run: node scripts/sync-data.js load');
                return null;
            }
            
            const response = await fetch(`${this.MONTHS_DIR}${monthKey}.json`);
            if (!response.ok) {
                return null;
            }
            const monthData = await response.json();
            console.log(`✓ Loaded ${monthKey}.json from files`);
            return monthData;
        } catch (error) {
            console.error(`Error loading ${monthKey}.json:`, error);
            return null;
        }
    },

    /**
     * Load all months from individual JSON files
     * @returns {Promise<Object>} Object with all months keyed by monthKey
     */
    async loadAllMonthsFromFiles() {
        if (window.location.protocol === 'file:') {
            console.log('Using file:// protocol - loading from localStorage.');
            console.log('To load from files, run: node scripts/sync-data.js load');
            return {};
        }
        
        const allMonths = {};
        const currentYear = new Date().getFullYear();
        const years = [currentYear - 1, currentYear, currentYear + 1];
        let loadedCount = 0;

        for (const year of years) {
            for (let month = 1; month <= 12; month++) {
                const monthKey = `${year}-${String(month).padStart(2, '0')}`;
                try {
                    const monthData = await this.loadMonthFromFile(monthKey);
                    if (monthData) {
                        allMonths[monthKey] = monthData;
                        loadedCount++;
                    }
                } catch (error) {
                    // File doesn't exist, skip
                }
            }
        }

        if (loadedCount > 0) {
            console.log(`✓ Loaded ${loadedCount} months from files`);
        } else {
            console.log('No month files found. Using localStorage data.');
            console.log('To sync files, run: node scripts/sync-data.js load');
        }

        return allMonths;
    },

    /**
     * Load months from file picker (File System Access API)
     * @returns {Promise<Object>} Result object with success, count, months, etc.
     */
    async loadMonthsFromFilePicker() {
        try {
            const isFileProtocol = window.location.protocol === 'file:';
            
            if ('showDirectoryPicker' in window && !isFileProtocol) {
                try {
                    const directoryHandle = await window.showDirectoryPicker();
                    const months = {};
                    let loadedCount = 0;
                    const htmlFiles = [];
                    const csvFiles = [];
                    
                    for await (const entry of directoryHandle.values()) {
                        if (entry.kind === 'file') {
                            if (entry.name.endsWith('.json')) {
                                try {
                                    const file = await entry.getFile();
                                    const content = await file.text();
                                    const monthData = JSON.parse(content);
                                    const monthKey = entry.name.replace('.json', '');
                                    months[monthKey] = monthData;
                                    loadedCount++;
                                    console.log(`✓ Loaded ${monthKey}.json`);
                                } catch (error) {
                                    console.error(`Error loading ${entry.name}:`, error);
                                }
                            } else if (entry.name.endsWith('.csv')) {
                                csvFiles.push(entry);
                            } else if (entry.name.endsWith('.html')) {
                                htmlFiles.push(entry);
                            }
                        }
                    }
                    
                    if (csvFiles.length > 0 && window.CSVHandler) {
                        for (const entry of csvFiles) {
                            try {
                                const file = await entry.getFile();
                                const csvText = await file.text();
                                const fileName = entry.name.toLowerCase();
                                const monthData = this.parseMonthFromFileName(fileName, csvText, 'csv');
                                if (monthData) {
                                    const monthKey = monthData.key;
                                    months[monthKey] = monthData;
                                    loadedCount++;
                                    console.log(`✓ Imported ${monthKey} from ${entry.name}`);
                                }
                            } catch (error) {
                                console.error(`Error importing CSV ${entry.name}:`, error);
                            }
                        }
                    }
                    
                    if (htmlFiles.length > 0 && window.ReferenceImporter) {
                        for (const entry of htmlFiles) {
                            try {
                                const file = await entry.getFile();
                                const fileName = entry.name.toLowerCase();
                                const monthInfo = this.extractMonthInfoFromFileName(fileName);
                                if (monthInfo) {
                                    const monthData = await window.ReferenceImporter.importMonthFromFile(file, monthInfo.monthName, monthInfo.year);
                                    if (monthData && monthData.key) {
                                        months[monthData.key] = monthData;
                                        loadedCount++;
                                        console.log(`✓ Imported ${monthData.key} from ${entry.name}`);
                                    }
                                }
                            } catch (error) {
                                console.error(`Error importing ${entry.name}:`, error);
                            }
                        }
                    }
                    
                    if (loadedCount > 0) {
                        return { success: true, count: loadedCount, months: months };
                    } else {
                        return { success: false, message: 'No valid month files found in directory' };
                    }
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.warn('Directory picker failed:', error);
                        return { success: false, message: error.message, useFileInput: true };
                    } else {
                        return { success: false, message: 'User cancelled' };
                    }
                }
            }
            
            return { success: false, message: 'File System Access API not available. Please use the file input button.', useFileInput: true };
        } catch (error) {
            console.error('Error loading months from files:', error);
            return { success: false, message: error.message, useFileInput: true };
        }
    },

    /**
     * Load months from file input (multiple files)
     * @param {FileList} files - File list from input element
     * @returns {Promise<Object>} Result object with success, count, errors, months
     */
    async loadMonthsFromFileInput(files) {
        const months = {};
        let loadedCount = 0;
        let errorCount = 0;
        const htmlFiles = [];
        const csvFiles = [];
        
        for (const file of files) {
            if (file.name.endsWith('.json')) {
                try {
                    const content = await file.text();
                    const monthData = JSON.parse(content);
                    const monthKey = file.name.replace('.json', '');
                    months[monthKey] = monthData;
                    loadedCount++;
                    console.log(`✓ Loaded ${monthKey}.json`);
                } catch (error) {
                    console.error(`Error loading ${file.name}:`, error);
                    errorCount++;
                }
            } else if (file.name.endsWith('.csv')) {
                csvFiles.push(file);
            } else if (file.name.endsWith('.html')) {
                htmlFiles.push(file);
            }
        }
        
        if (csvFiles.length > 0) {
            if (!window.CSVHandler) {
                console.error('CSVHandler not available. Cannot import CSV files.');
                errorCount += csvFiles.length;
            } else {
                for (const file of csvFiles) {
                    try {
                        const csvText = await file.text();
                        const fileName = file.name.toLowerCase();
                        const monthData = this.parseMonthFromFileName(fileName, csvText, 'csv');
                        if (monthData && monthData.key) {
                            months[monthData.key] = monthData;
                            loadedCount++;
                            console.log(`✓ Imported ${monthData.key} from ${file.name}`);
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        console.error(`Error importing CSV ${file.name}:`, error);
                        errorCount++;
                    }
                }
            }
        }
        
        if (htmlFiles.length > 0) {
            if (!window.ReferenceImporter) {
                console.error('ReferenceImporter not available. Cannot import HTML files.');
                errorCount += htmlFiles.length;
            } else {
                for (const file of htmlFiles) {
                    try {
                        const fileName = file.name.toLowerCase();
                        const monthInfo = this.extractMonthInfoFromFileName(fileName);
                        if (monthInfo) {
                            const monthData = await window.ReferenceImporter.importMonthFromFile(file, monthInfo.monthName, monthInfo.year);
                            if (monthData && monthData.key) {
                                months[monthData.key] = monthData;
                                loadedCount++;
                                console.log(`✓ Imported ${monthData.key} from ${file.name}`);
                            } else {
                                errorCount++;
                            }
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        console.error(`Error importing ${file.name}:`, error);
                        errorCount++;
                    }
                }
            }
        }
        
        return { success: loadedCount > 0, count: loadedCount, errors: errorCount, months: months };
    },

    /**
     * Extract month name and year from filename
     * @param {string} fileName - Filename (lowercase)
     * @returns {Object|null} Object with monthName and year, or null
     */
    extractMonthInfoFromFileName(fileName) {
        const monthNames = ['january', 'february', 'march', 'april', 'may', 'june', 
                          'july', 'august', 'september', 'october', 'november', 'december'];
        
        let monthName = null;
        let year = new Date().getFullYear();
        
        for (const month of monthNames) {
            if (fileName.includes(month)) {
                monthName = month.charAt(0).toUpperCase() + month.slice(1);
                break;
            }
        }
        
        const yearMatch = fileName.match(/\b(20\d{2})\b/);
        if (yearMatch) {
            year = parseInt(yearMatch[1], 10);
        }
        
        if (!monthName) {
            const nameMatch = fileName.match(/^([a-z]+)-(\d{4})\./i);
            if (nameMatch) {
                monthName = nameMatch[1].charAt(0).toUpperCase() + nameMatch[1].slice(1).toLowerCase();
                year = parseInt(nameMatch[2], 10);
            } else {
                return null;
            }
        }
        
        return { monthName, year };
    },

    /**
     * Parse month data from filename and content
     * @param {string} fileName - Filename (lowercase)
     * @param {string} content - File content
     * @param {string} format - File format ('csv' or 'html')
     * @returns {Object|null} Month data or null
     */
    parseMonthFromFileName(fileName, content, format) {
        const monthInfo = this.extractMonthInfoFromFileName(fileName);
        if (!monthInfo) {
            return null;
        }

        if (format === 'csv' && window.CSVHandler) {
            return window.CSVHandler.csvToMonthData(content, monthInfo.monthName, monthInfo.year);
        }

        return null;
    }
};

if (typeof window !== 'undefined') {
    window.FileService = FileService;
}


// ===== services/ExportService.js =====
/**
 * Export Service
 * Handles exporting month data to various formats
 * @module services/ExportService
 */

const ExportService = {
    /**
     * Export month data to file
     * @param {string} monthKey - Month key
     * @param {Object} monthData - Month data object
     * @param {string} format - Export format ('json', 'csv', 'html')
     * @returns {Promise<boolean>} Success status
     */
    async exportMonthToFile(monthKey, monthData, format = 'json') {
        try {
            let blob;
            let filename;
            let mimeType;
            let fileExtension;
            
            if (format === 'csv') {
                if (!window.CSVHandler) {
                    console.error('CSVHandler not available. Cannot export CSV.');
                    return false;
                }
                const csvString = window.CSVHandler.monthDataToCSV(monthData);
                blob = new Blob([csvString], { type: 'text/csv' });
                filename = `${monthKey}.csv`;
                mimeType = 'text/csv';
                fileExtension = '.csv';
            } else if (format === 'html') {
                const htmlString = this.monthDataToHTML(monthData, monthKey);
                blob = new Blob([htmlString], { type: 'text/html' });
                filename = `${monthKey}.html`;
                mimeType = 'text/html';
                fileExtension = '.html';
            } else {
                const jsonString = JSON.stringify(monthData, null, 2);
                blob = new Blob([jsonString], { type: 'application/json' });
                filename = `${monthKey}.json`;
                mimeType = 'application/json';
                fileExtension = '.json';
            }
            
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: filename,
                        types: [{
                            description: format === 'csv' ? 'CSV files' : format === 'html' ? 'HTML files' : 'JSON files',
                            accept: { [mimeType]: [fileExtension] }
                        }],
                        startIn: 'downloads'
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    
                    console.log(`✓ Month ${monthKey} saved as ${format.toUpperCase()} directly to file system`);
                    return true;
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.warn('File System Access API failed, falling back to download:', error);
                    } else {
                        return false;
                    }
                }
            }
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            console.log(`✓ Month ${monthKey} downloaded as ${format.toUpperCase()}. Save it to data/months/ folder.`);
            return true;
        } catch (error) {
            console.error('Error exporting month file:', error);
            return false;
        }
    },

    /**
     * Save all months to files
     * @param {Object} allMonths - Object with all months
     * @returns {Promise<Object>} Result object
     */
    async saveAllMonthsToFiles(allMonths) {
        const monthKeys = Object.keys(allMonths);
        
        if (monthKeys.length === 0) {
            return { success: false, message: 'No months to save' };
        }
        
        try {
            const isFileProtocol = window.location.protocol === 'file:';
            
            if ('showDirectoryPicker' in window && !isFileProtocol) {
                try {
                    const directoryHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                    let savedCount = 0;
                    let errorCount = 0;
                    
                    for (const monthKey of monthKeys) {
                        try {
                            const monthData = allMonths[monthKey];
                            
                            const jsonString = JSON.stringify(monthData, null, 2);
                            const jsonBlob = new Blob([jsonString], { type: 'application/json' });
                            const jsonFileHandle = await directoryHandle.getFileHandle(`${monthKey}.json`, { create: true });
                            const jsonWritable = await jsonFileHandle.createWritable();
                            await jsonWritable.write(jsonBlob);
                            await jsonWritable.close();
                            
                            if (window.CSVHandler) {
                                try {
                                    const csvString = window.CSVHandler.monthDataToCSV(monthData);
                                    const csvBlob = new Blob([csvString], { type: 'text/csv' });
                                    const csvFileHandle = await directoryHandle.getFileHandle(`${monthKey}.csv`, { create: true });
                                    const csvWritable = await csvFileHandle.createWritable();
                                    await csvWritable.write(csvBlob);
                                    await csvWritable.close();
                                    console.log(`✓ Saved ${monthKey}.csv`);
                                } catch (csvError) {
                                    console.warn(`Could not save ${monthKey}.csv:`, csvError);
                                }
                            }
                            
                            savedCount++;
                            console.log(`✓ Saved ${monthKey}.json`);
                        } catch (error) {
                            console.error(`Error saving ${monthKey}:`, error);
                            errorCount++;
                        }
                    }
                    
                    return { 
                        success: savedCount > 0, 
                        count: savedCount, 
                        errors: errorCount,
                        message: `Saved ${savedCount} months to directory${errorCount > 0 ? ` (${errorCount} errors)` : ''}` 
                    };
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.warn('Directory picker failed, falling back to downloads:', error);
                    } else {
                        return { success: false, message: 'User cancelled' };
                    }
                }
            }
            
            let downloadedCount = 0;
            const downloadPromises = [];
            
            for (const monthKey of monthKeys) {
                const monthData = allMonths[monthKey];
                downloadPromises.push(
                    this.exportMonthToFile(monthKey, monthData, 'json').then(() => {
                        downloadedCount++;
                    }).catch(error => {
                        console.error(`Error downloading ${monthKey}.json:`, error);
                    })
                );
                await new Promise(resolve => setTimeout(resolve, 200));
                
                if (window.CSVHandler) {
                    downloadPromises.push(
                        this.exportMonthToFile(monthKey, monthData, 'csv').then(() => {
                            // CSV download doesn't count separately
                        }).catch(error => {
                            console.warn(`Could not download ${monthKey}.csv:`, error);
                        })
                    );
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }
            
            await Promise.all(downloadPromises);
            
            const fileTypeText = window.CSVHandler ? 'JSON and CSV files' : 'JSON files';
            return { 
                success: downloadedCount > 0, 
                count: downloadedCount,
                message: `Downloaded ${downloadedCount} month ${fileTypeText}${downloadedCount !== 1 ? 's' : ''}. Save ${downloadedCount === 1 ? 'it' : 'them'} to data/months/ folder.` 
            };
        } catch (error) {
            console.error('Error saving all months:', error);
            return { success: false, message: error.message };
        }
    },

    /**
     * Generate HTML representation of month data
     * @param {Object} monthData - Month data object
     * @param {string} monthKey - Month key
     * @returns {string} HTML string
     */
    monthDataToHTML(monthData, monthKey) {
        if (!window.Formatters || !window.CalculationService) {
            throw new Error('Formatters and CalculationService must be available');
        }

        const formatCurrency = (amount) => {
            if (amount === null || amount === undefined) return window.Formatters.formatCurrency(0);
            return window.Formatters.formatCurrency(amount);
        };

        const formatDate = (dateString) => {
            if (!dateString) return '';
            try {
                return new Date(dateString).toLocaleDateString('en-GB');
            } catch {
                return dateString;
            }
        };

        const monthName = monthData.monthName || this.getMonthName(monthData.month);
        const year = monthData.year;
        const totals = window.CalculationService.calculateMonthTotals(monthData);

        const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${monthName} ${year} - Monthly Budget</title>
    <style>
        html { -webkit-print-color-adjust: exact; }
        * { box-sizing: border-box; -webkit-print-color-adjust: exact; }
        html, body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.5; color: #333; }
        @media only screen { body { margin: 2em auto; max-width: 900px; background-color: #f8f9fa; } }
        body { white-space: pre-wrap; background-color: white; }
        .header { text-align: center; padding: 2rem 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; margin-bottom: 2rem; }
        .header h1 { margin: 0; font-size: 2.5rem; font-weight: 300; }
        .header p { margin: 0.5rem 0 0 0; opacity: 0.9; }
        .section { margin-bottom: 2rem; background: white; border-radius: 0px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); overflow: hidden; }
        .section-header { background: #f8f9fa; padding: 1rem 1.5rem; border-bottom: 1px solid #e9ecef; }
        .section-title { margin: 0; font-size: 1.5rem; font-weight: 600; color: #495057; }
        table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
        th, td { padding: 0.75rem 1rem; text-align: left; border-bottom: 1px solid #e9ecef; }
        th { background-color: #f8f9fa; font-weight: 600; color: #495057; border-bottom: 2px solid #dee2e6; }
        .total-row { background-color: #fff3cd; font-weight: 600; }
        .total-row td { border-top: 2px solid #ffc107; }
        .summary-section { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; }
        .summary-section .section-title { color: white; }
        .summary-section table { color: #333; }
        .summary-section .total-row { background-color: rgba(255,255,255,0.2); color: white; }
        .summary-section .total-row td { border-top: 2px solid rgba(255,255,255,0.5); }
        .export-info { background: #e9ecef; padding: 1rem; margin-top: 2rem; border-radius: 0px; font-size: 0.875rem; color: #6c757d; }
        .export-info strong { color: #495057; }
        @media print { body { background: white !important; margin: 0 !important; max-width: none !important; } .section { box-shadow: none !important; border: 1px solid #ddd !important; } .export-info { display: none; } }
    </style>
</head>
<body>
    <div class="header">
        <h1>${monthName} ${year}</h1>
        <p>Monthly Budget Report</p>
    </div>
    ${this.renderHTMLSection('Weekly Breakdown', monthData.weeklyBreakdown, [
        { key: 'dateRange', label: 'Date Range' },
        { key: 'paymentsDue', label: 'Payments Due' },
        { key: 'groceries', label: 'Groceries' },
        { key: 'transport', label: 'Transport' },
        { key: 'activities', label: 'Activities' },
        { key: 'estimate', label: 'Estimate', type: 'currency' },
        { key: 'actual', label: 'Actual', type: 'currency' }
    ], formatCurrency, formatDate)}
    ${this.renderHTMLSection('Income Sources', monthData.incomeSources, [
        { key: 'source', label: 'Source' },
        { key: 'estimated', label: 'Estimated', type: 'currency' },
        { key: 'actual', label: 'Actual', type: 'currency' },
        { key: 'date', label: 'Date', type: 'date' },
        { key: 'description', label: 'Description' },
        { key: 'comments', label: 'Comments' }
    ], formatCurrency, formatDate, totals.income)}
    ${this.renderHTMLSection('Fixed Costs', monthData.fixedCosts, [
        { key: 'category', label: 'Category' },
        { key: 'estimatedAmount', label: 'Estimated', type: 'currency' },
        { key: 'actualAmount', label: 'Actual', type: 'currency' },
        { key: 'date', label: 'Date', type: 'date' },
        { key: 'card', label: 'Card' },
        { key: 'paid', label: 'Paid', type: 'boolean' },
        { key: 'comments', label: 'Comments' }
    ], formatCurrency, formatDate, totals.fixedCosts)}
    ${this.renderHTMLSection('Variable Costs', monthData.variableCosts, [
        { key: 'category', label: 'Category' },
        { key: 'estimatedAmount', label: 'Budget', type: 'currency' },
        { key: 'actualAmount', label: 'Actual', type: 'currency' },
        { key: 'comments', label: 'Comments' }
    ], formatCurrency, formatDate, totals.variableCosts)}
    ${monthData.unplannedExpenses && monthData.unplannedExpenses.length > 0 ? this.renderHTMLSection('Unplanned Expenses', monthData.unplannedExpenses, [
        { key: 'name', label: 'Name' },
        { key: 'amount', label: 'Amount', type: 'currency' },
        { key: 'date', label: 'Date', type: 'date' },
        { key: 'card', label: 'Card' },
        { key: 'status', label: 'Status' },
        { key: 'comments', label: 'Comments' }
    ], formatCurrency, formatDate, { actual: totals.unplannedExpenses.actual }) : ''}
    ${monthData.pots && monthData.pots.length > 0 ? this.renderHTMLSection('Savings & Investments', monthData.pots, [
        { key: 'category', label: 'Category' },
        { key: 'estimatedAmount', label: 'Estimated', type: 'currency' },
        { key: 'actualAmount', label: 'Actual', type: 'currency' }
    ], formatCurrency, formatDate, totals.pots) : ''}
    ${this.renderSummarySection(totals, formatCurrency)}
    <div class="export-info">
        <strong>Export Details:</strong><br>
        Generated on ${new Date().toLocaleString()}<br>
        Format: HTML Report<br>
        Source: Money Tracker Application
    </div>
</body>
</html>`;

        return html;
    },

    /**
     * Render HTML section for a data array
     * @private
     */
    renderHTMLSection(title, items, columns, formatCurrency, formatDate, totals = null) {
        if (!items || items.length === 0) return '';

        const rows = items.map(item => {
            const cells = columns.map(col => {
                let value = item[col.key];
                if (col.type === 'currency') {
                    value = formatCurrency(value);
                } else if (col.type === 'date') {
                    value = formatDate(value);
                } else if (col.type === 'boolean') {
                    value = value ? '✓' : '';
                }
                return `<td>${value || ''}</td>`;
            }).join('');
            return `<tr>${cells}</tr>`;
        }).join('');

        let totalRow = '';
        if (totals) {
            const totalCells = columns.map((col, idx) => {
                if (idx === 0) return '<td><strong>Total</strong></td>';
                if (col.type === 'currency') {
                    const totalValue = totals.estimated !== undefined ? totals.estimated : totals.actual;
                    return `<td><strong>${formatCurrency(totalValue)}</strong></td>`;
                }
                return '<td></td>';
            }).join('');
            totalRow = `<tr class="total-row">${totalCells}</tr>`;
        }

        return `
    <div class="section">
        <div class="section-header">
            <h2 class="section-title">${title}</h2>
        </div>
        <table>
            <thead>
                <tr>${columns.map(col => `<th>${col.label}</th>`).join('')}</tr>
            </thead>
            <tbody>
                ${rows}
                ${totalRow}
            </tbody>
        </table>
    </div>`;
    },

    /**
     * Render summary section
     * @private
     */
    renderSummarySection(totals, formatCurrency) {
        return `
    <div class="section summary-section">
        <div class="section-header">
            <h2 class="section-title">Monthly Summary</h2>
        </div>
        <table>
            <thead>
                <tr>
                    <th>Category</th>
                    <th>Estimated</th>
                    <th>Actual</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Total Income</strong></td>
                    <td><strong>${formatCurrency(totals.income.estimated)}</strong></td>
                    <td><strong>${formatCurrency(totals.income.actual)}</strong></td>
                </tr>
                <tr>
                    <td>Total Fixed Costs</td>
                    <td>${formatCurrency(totals.fixedCosts.estimated)}</td>
                    <td>${formatCurrency(totals.fixedCosts.actual)}</td>
                </tr>
                <tr>
                    <td>Total Variable Costs</td>
                    <td>${formatCurrency(totals.variableCosts.estimated)}</td>
                    <td>${formatCurrency(totals.variableCosts.actual)}</td>
                </tr>
                <tr>
                    <td><strong>Total Expenses</strong></td>
                    <td><strong>${formatCurrency(totals.expenses.estimated)}</strong></td>
                    <td><strong>${formatCurrency(totals.expenses.actual)}</strong></td>
                </tr>
                <tr>
                    <td>Total Unplanned Expenses</td>
                    <td>—</td>
                    <td>${formatCurrency(totals.unplannedExpenses.actual)}</td>
                </tr>
                <tr class="total-row">
                    <td><strong>Grand Savings Total</strong></td>
                    <td><strong>${formatCurrency(totals.savings.estimated)}</strong></td>
                    <td><strong>${formatCurrency(totals.savings.actual)}</strong></td>
                </tr>
            </tbody>
        </table>
    </div>`;
    },

    /**
     * Get month name from month number
     * @private
     */
    getMonthName(monthNumber) {
        const monthNames = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];
        return monthNames[monthNumber - 1] || '';
    }
};

if (typeof window !== 'undefined') {
    window.ExportService = ExportService;
}


// ===== models/DataManager.js =====
/**
 * Data Manager Model
 * Core data operations using localStorage and file services
 * @module models/DataManager
 */

const DataManager = {
    STORAGE_KEY_MONTHS: 'money_tracker_months',
    STORAGE_KEY_POTS: 'money_tracker_pots',
    STORAGE_KEY_SETTINGS: 'money_tracker_settings',

    /**
     * Initialize default settings if they don't exist
     * @returns {Object} Settings object
     */
    initializeSettings() {
        const existingSettings = this.getSettings();
        if (!existingSettings) {
            const defaultSettings = {
                currency: '£',
                defaultFixedCosts: [],
                defaultVariableCategories: ['Food', 'Travel/Transport', 'Activities'],
                defaultPots: []
            };
            this.saveSettings(defaultSettings);
            return defaultSettings;
        }
        return existingSettings;
    },

    /**
     * Get all months data from localStorage
     * @returns {Object} Object with all months keyed by monthKey
     */
    getAllMonths() {
        return window.StorageService.get(this.STORAGE_KEY_MONTHS) || {};
    },

    /**
     * Save all months data to localStorage
     * @param {Object} monthsData - Object with all months
     * @returns {boolean} Success status
     */
    saveAllMonths(monthsData) {
        return window.StorageService.set(this.STORAGE_KEY_MONTHS, monthsData);
    },

    /**
     * Get a specific month's data from localStorage
     * @param {string} monthKey - Month key (e.g., "2025-11")
     * @returns {Object|null} Month data or null
     */
    getMonth(monthKey) {
        const allMonths = this.getAllMonths();
        return allMonths[monthKey] || null;
    },

    /**
     * Save a specific month's data to localStorage and export as file
     * @param {string} monthKey - Month key
     * @param {Object} monthData - Month data object
     * @param {boolean} exportFile - Whether to export to file
     * @returns {boolean} Success status
     */
    saveMonth(monthKey, monthData, exportFile = true) {
        if (!monthKey || !monthData) {
            throw new Error('Month key and data are required');
        }

        monthData.updatedAt = new Date().toISOString();
        if (!monthData.createdAt) {
            monthData.createdAt = new Date().toISOString();
        }
        
        const allMonths = this.getAllMonths();
        allMonths[monthKey] = monthData;
        const saved = this.saveAllMonths(allMonths);
        
        if (saved && exportFile && window.ExportService) {
            window.ExportService.exportMonthToFile(monthKey, monthData, 'json').catch(error => {
                console.error('Error exporting month file:', error);
            });
        }
        
        return saved;
    },

    /**
     * Delete a month from localStorage
     * @param {string} monthKey - Month key
     * @returns {boolean} Success status
     */
    deleteMonth(monthKey) {
        const allMonths = this.getAllMonths();
        delete allMonths[monthKey];
        return this.saveAllMonths(allMonths);
    },

    /**
     * Load all months from individual JSON files into localStorage
     * @returns {Promise<Object>} Object with all months
     */
    async loadMonthsFromFiles() {
        if (!window.FileService) {
            console.error('FileService not available');
            return this.getAllMonths();
        }

        const fileMonths = await window.FileService.loadAllMonthsFromFiles();
        const localStorageMonths = this.getAllMonths();
        
        const allMonths = { ...fileMonths };
        Object.keys(localStorageMonths).forEach(key => {
            if (!allMonths[key]) {
                allMonths[key] = localStorageMonths[key];
            }
        });

        if (Object.keys(fileMonths).length > 0) {
            this.saveAllMonths(allMonths);
        }

        return allMonths;
    },

    /**
     * Load months from file picker
     * @returns {Promise<Object>} Result object
     */
    async loadMonthsFromFilePicker() {
        if (!window.FileService) {
            return { success: false, message: 'FileService not available', useFileInput: true };
        }
        return await window.FileService.loadMonthsFromFilePicker();
    },

    /**
     * Load months from file input
     * @param {FileList} files - File list
     * @returns {Promise<Object>} Result object
     */
    async loadMonthsFromFileInput(files) {
        if (!window.FileService) {
            return { success: false, count: 0, errors: files.length, months: {} };
        }
        const result = await window.FileService.loadMonthsFromFileInput(files);
        if (result.success && result.months) {
            const allMonths = this.getAllMonths();
            Object.assign(allMonths, result.months);
            this.saveAllMonths(allMonths);
        }
        return result;
    },

    /**
     * Save all months to files
     * @returns {Promise<Object>} Result object
     */
    async saveAllMonthsToFiles() {
        if (!window.ExportService) {
            return { success: false, message: 'ExportService not available' };
        }
        const allMonths = this.getAllMonths();
        return await window.ExportService.saveAllMonthsToFiles(allMonths);
    },

    /**
     * Export month to file
     * @param {string} monthKey - Month key
     * @param {Object} monthData - Month data
     * @param {string} format - Format ('json', 'csv', 'html')
     * @returns {Promise<boolean>} Success status
     */
    async exportMonthToFile(monthKey, monthData, format = 'json') {
        if (!window.ExportService) {
            console.error('ExportService not available');
            return false;
        }
        return await window.ExportService.exportMonthToFile(monthKey, monthData, format);
    },

    /**
     * Get all pots data
     * @returns {Object} Pots data object
     */
    getAllPots() {
        return window.StorageService.get(this.STORAGE_KEY_POTS) || {};
    },

    /**
     * Save all pots data
     * @param {Object} potsData - Pots data object
     * @returns {boolean} Success status
     */
    saveAllPots(potsData) {
        return window.StorageService.set(this.STORAGE_KEY_POTS, potsData);
    },

    /**
     * Get settings
     * @returns {Object|null} Settings object or null
     */
    getSettings() {
        return window.StorageService.get(this.STORAGE_KEY_SETTINGS);
    },

    /**
     * Save settings
     * @param {Object} settings - Settings object
     * @returns {boolean} Success status
     */
    saveSettings(settings) {
        return window.StorageService.set(this.STORAGE_KEY_SETTINGS, settings);
    },

    /**
     * Generate a month key from year and month
     * @param {number} year - Year
     * @param {number} month - Month (1-12)
     * @returns {string} Month key
     */
    generateMonthKey(year, month) {
        return window.MonthFactory.generateMonthKey(year, month);
    },

    /**
     * Parse month key to year and month
     * @param {string} monthKey - Month key
     * @returns {Object} Object with year and month
     */
    parseMonthKey(monthKey) {
        return window.MonthFactory.parseMonthKey(monthKey);
    },

    /**
     * Get month name from month number
     * @param {number} monthNumber - Month number (1-12)
     * @returns {string} Month name
     */
    getMonthName(monthNumber) {
        return window.MonthFactory.getMonthName(monthNumber);
    },

    /**
     * Create a new month with default structure
     * @param {number} year - Year
     * @param {number} month - Month (1-12)
     * @returns {Object} New month data object
     */
    createNewMonth(year, month) {
        const settings = this.getSettings() || this.initializeSettings();
        const newMonth = window.MonthFactory.createNewMonth(year, month, settings);
        const monthKey = newMonth.key;
        this.saveMonth(monthKey, newMonth, true);
        return newMonth;
    },

    /**
     * Calculate totals for a month
     * @param {Object} monthData - Month data object
     * @returns {Object} Totals object
     */
    calculateMonthTotals(monthData) {
        if (!window.CalculationService) {
            throw new Error('CalculationService not available');
        }
        return window.CalculationService.calculateMonthTotals(monthData);
    },

    /**
     * Generate HTML representation of month data
     * @param {Object} monthData - Month data object
     * @param {string} monthKey - Month key
     * @returns {string} HTML string
     */
    monthDataToHTML(monthData, monthKey) {
        if (!window.ExportService) {
            throw new Error('ExportService not available');
        }
        return window.ExportService.monthDataToHTML(monthData, monthKey);
    }
};

if (typeof window !== 'undefined') {
    DataManager.initializeSettings();
    window.DataManager = DataManager;
}


// ===== components/Header.js =====
/**
 * Shared Header Component
 * Renders consistent navigation header across all pages
 */

class Header {
    /**
     * Get the current page name from the current URL
     */
    static getCurrentPage() {
        const path = window.location.pathname;
        const filename = path.split('/').pop() || 'index.html';
        
        if (filename === 'index.html' || filename === '') {
            return 'Home';
        } else if (filename.includes('monthly-budget')) {
            return 'Monthly Budget';
        } else if (filename.includes('pots')) {
            return 'Pots & Investments';
        } else if (filename.includes('settings')) {
            return 'Settings';
        } else if (filename.includes('import')) {
            return 'Settings';
        }
        return 'Home';
    }

    /**
     * Get the base path for navigation links
     */
    static getBasePath() {
        const path = window.location.pathname;
        // If we're in the views folder, go up one level
        if (path.includes('/views/')) {
            return '../';
        }
        return '';
    }

    /**
     * Render the header HTML
     */
    static render() {
        const currentPage = this.getCurrentPage();
        const basePath = this.getBasePath();
        
        const navItems = [
            { name: 'Home', href: basePath + 'index.html', page: 'Home' },
            { name: 'Monthly Budget', href: basePath + 'views/monthly-budget.html', page: 'Monthly Budget' },
            { name: 'Pots & Investments', href: basePath + 'views/pots.html', page: 'Pots & Investments' },
            { name: 'Settings', href: basePath + 'views/settings.html', page: 'Settings' }
        ];

        const navLinks = navItems.map(item => {
            const isActive = item.page === currentPage;
            const activeClass = isActive ? ' active' : '';
            const ariaCurrent = isActive ? ' aria-current="page"' : '';
            return `<li><a href="${item.href}" class="nav-link${activeClass}"${ariaCurrent}>${item.name}</a></li>`;
        }).join('\n                ');

        return `
    <header class="main-header">
        <nav class="main-navigation" role="navigation" aria-label="Main navigation">
            <div class="header-title-group">
                <h1 class="site-title">Money Tracker</h1>
                <button class="hamburger-menu" aria-label="Toggle navigation menu" aria-expanded="false">
                    <span class="hamburger-line"></span>
                    <span class="hamburger-line"></span>
                    <span class="hamburger-line"></span>
                </button>
            </div>
            <ul class="nav-list">
                ${navLinks}
            </ul>
        </nav>
    </header>`;
    }

    /**
     * Initialize and inject header into the page
     */
    static init() {
        // Find where to insert the header (before main or body's first child)
        const main = document.querySelector('main');
        const body = document.body;
        
        if (main) {
            // Insert before main element
            main.insertAdjacentHTML('beforebegin', this.render());
        } else if (body) {
            // Insert as first child of body
            body.insertAdjacentHTML('afterbegin', this.render());
        } else {
            console.error('Header: Could not find insertion point');
            return;
        }

        // Initialize hamburger menu functionality
        this.initHamburgerMenu();
    }

    /**
     * Initialize hamburger menu functionality
     */
    static initHamburgerMenu() {
        const hamburgerBtn = document.querySelector('.hamburger-menu');
        const navList = document.querySelector('.nav-list');

        if (!hamburgerBtn || !navList) return;

        hamburgerBtn.addEventListener('click', () => {
            const isExpanded = hamburgerBtn.getAttribute('aria-expanded') === 'true';
            hamburgerBtn.setAttribute('aria-expanded', !isExpanded);
            navList.classList.toggle('nav-open');
        });

        // Close menu when clicking outside or on a link
        document.addEventListener('click', (e) => {
            if (!hamburgerBtn.contains(e.target) && !navList.contains(e.target)) {
                hamburgerBtn.setAttribute('aria-expanded', 'false');
                navList.classList.remove('nav-open');
            }
        });

        // Close menu when a link is clicked
        navList.addEventListener('click', (e) => {
            if (e.target.classList.contains('nav-link')) {
                hamburgerBtn.setAttribute('aria-expanded', 'false');
                navList.classList.remove('nav-open');
            }
        });
    }
}

// Auto-initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => Header.init());
} else {
    Header.init();
}

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = Header;
}



// ===== utils/InitialData.js =====
/**
 * Initial Data Loader
 * Loads initial months data from individual JSON files in data/months/
 */

const InitialData = {
    /**
     * Initialize with months from individual JSON files if localStorage is empty
     */
    async initializeIfEmpty() {
        const allMonths = DataManager.getAllMonths();
        
        if (Object.keys(allMonths).length === 0) {
            // Try to load from files (will fail gracefully with file:// protocol)
            const loadedMonths = await DataManager.loadMonthsFromFiles();
            if (Object.keys(loadedMonths).length > 0) {
                console.log(`Initialized with ${Object.keys(loadedMonths).length} months from individual JSON files`);
                return true;
            } else {
                // localStorage is empty and files couldn't be loaded (file:// protocol)
                console.log('No months found. Use the Import page to load data from JSON files, or create a new month.');
            }
        } else {
            // Months exist in localStorage, try to sync with files if possible
            await DataManager.loadMonthsFromFiles();
        }
        return false;
    }
};

// Make available globally
if (typeof window !== 'undefined') {
    window.InitialData = InitialData;
}


// ===== controllers/LandingController.js =====
/**
 * Landing Page Controller
 * Handles the landing page view logic including financial overview
 * @module controllers/LandingController
 */

const LandingController = {
    /**
     * Initialize the landing page
     * @returns {Promise<void>}
     */
    async init() {
        await DataManager.loadMonthsFromFiles();
        this.loadOverviewData();
        this.setupEventListeners();
    },

    /**
     * Load and display overview data including summary cards, comparison table, and trends
     * @returns {void}
     */
    loadOverviewData() {
        const allMonths = DataManager.getAllMonths();
        const monthKeys = Object.keys(allMonths).sort();

        if (monthKeys.length === 0) {
            this.renderEmptyState();
            return;
        }

        let overallIncomeTotal = 0;
        let overallExpensesTotal = 0;
        let overallSavingsTotal = 0;
        let overallPotsTotal = 0;

        const tableBody = document.getElementById('months-comparison-tbody');
        if (tableBody) {
            tableBody.innerHTML = '';

            monthKeys.forEach(monthKey => {
                const monthData = allMonths[monthKey];
                const totals = DataManager.calculateMonthTotals(monthData);
                
                overallIncomeTotal += totals.income.actual;
                overallExpensesTotal += totals.expenses.actual;
                overallSavingsTotal += totals.savings.actual;
                overallPotsTotal += totals.pots.actual;

                const monthDisplayName = monthData.monthName || DataManager.getMonthName(monthData.month);
                const tableRow = document.createElement('tr');
                
                tableRow.innerHTML = `
                    <td><strong>${monthDisplayName} ${monthData.year}</strong></td>
                    <td>${Formatters.formatCurrency(totals.income.actual)}</td>
                    <td>${Formatters.formatCurrency(totals.fixedCosts.actual)}</td>
                    <td>${Formatters.formatCurrency(totals.variableCosts.actual)}</td>
                    <td>${Formatters.formatCurrency(totals.unplannedExpenses.actual)}</td>
                    <td><strong>${Formatters.formatCurrency(totals.expenses.actual)}</strong></td>
                    <td>${Formatters.formatCurrency(totals.pots.actual)}</td>
                    <td class="${totals.savings.actual >= 0 ? 'positive' : 'negative'}"><strong>${Formatters.formatCurrency(totals.savings.actual)}</strong></td>
                    <td>
                        <a href="views/monthly-budget.html?month=${monthKey}" class="btn btn-action btn-sm">View</a>
                        <button type="button" class="delete-row-x" aria-label="Delete month" data-month-key="${monthKey}" data-month-name="${monthDisplayName} ${monthData.year}">x</button>
                    </td>
                `;

                const deleteButton = tableRow.querySelector('.delete-row-x');
                if (deleteButton) {
                    deleteButton.addEventListener('click', () => {
                        this.deleteMonth(monthKey, deleteButton.dataset.monthName);
                    });
                }

                tableBody.appendChild(tableRow);
            });
        }

        this.setElementText('overall-income', Formatters.formatCurrency(overallIncomeTotal));
        this.setElementText('overall-expenses', Formatters.formatCurrency(overallExpensesTotal));
        this.setElementText('overall-savings', Formatters.formatCurrency(overallSavingsTotal));
        this.setElementText('overall-pots', Formatters.formatCurrency(overallPotsTotal));

        const savingsElement = document.getElementById('overall-savings');
        if (savingsElement) {
            savingsElement.className = 'summary-card-value ' + (overallSavingsTotal >= 0 ? 'positive' : 'negative');
        }

        this.renderTrends(monthKeys, allMonths);
    },

    /**
     * Render empty state when no months exist
     * @returns {void}
     */
    renderEmptyState() {
        const tableBody = document.getElementById('months-comparison-tbody');
        const trendsContainer = document.getElementById('trends-container');
        
        if (tableBody) {
            tableBody.innerHTML = '<tr><td colspan="9" class="empty-message">No monthly data available. Create a month to get started.</td></tr>';
        }
        if (trendsContainer) {
            trendsContainer.innerHTML = '<p class="empty-message">No data available for trends analysis.</p>';
        }
    },

    /**
     * Render trends analysis
     * @param {Array<string>} monthKeys - Sorted array of month keys
     * @param {Object} allMonths - Object containing all month data
     * @returns {void}
     */
    renderTrends(monthKeys, allMonths) {
        const trendsContainer = document.getElementById('trends-container');
        if (!trendsContainer) return;
        
        if (monthKeys.length < 2) {
            trendsContainer.innerHTML = '<p class="empty-message">Need at least 2 months of data to show trends.</p>';
            return;
        }

        const incomeTrend = this.calculateTrend(monthKeys, allMonths, 'income');
        const expensesTrend = this.calculateTrend(monthKeys, allMonths, 'expenses');
        const savingsTrend = this.calculateTrend(monthKeys, allMonths, 'savings');

        trendsContainer.innerHTML = `
            <div class="trend-item">
                <h3>Income Trend</h3>
                <p>Average monthly income: ${Formatters.formatCurrency(incomeTrend.average)}</p>
                <p>Trend: ${incomeTrend.direction} ${incomeTrend.percentage > 0 ? '+' : ''}${incomeTrend.percentage.toFixed(1)}%</p>
            </div>
            <div class="trend-item">
                <h3>Expenses Trend</h3>
                <p>Average monthly expenses: ${Formatters.formatCurrency(expensesTrend.average)}</p>
                <p>Trend: ${expensesTrend.direction} ${expensesTrend.percentage > 0 ? '+' : ''}${expensesTrend.percentage.toFixed(1)}%</p>
            </div>
            <div class="trend-item">
                <h3>Savings Trend</h3>
                <p>Average monthly savings: ${Formatters.formatCurrency(savingsTrend.average)}</p>
                <p>Trend: ${savingsTrend.direction} ${savingsTrend.percentage > 0 ? '+' : ''}${savingsTrend.percentage.toFixed(1)}%</p>
            </div>
        `;
    },

    /**
     * Calculate trend for a specific metric
     * @param {Array<string>} monthKeys - Sorted array of month keys
     * @param {Object} allMonths - Object containing all month data
     * @param {string} metricType - Type of metric ('income', 'expenses', 'savings')
     * @returns {Object} Trend data with average, percentage, and direction
     */
    calculateTrend(monthKeys, allMonths, metricType) {
        if (!window.CalculationService) {
            throw new Error('CalculationService not available');
        }
        return window.CalculationService.calculateTrend(monthKeys, allMonths, metricType);
    },

    /**
     * Setup event listeners
     * @returns {void}
     */
    setupEventListeners() {
        const createNewMonthButton = document.getElementById('create-new-month-button');

        if (createNewMonthButton) {
            createNewMonthButton.addEventListener('click', () => this.handleCreateNewMonth());
        }
    },

    /**
     * Handle create new month action
     * @returns {Promise<void>}
     */
    async handleCreateNewMonth() {
        const currentDate = new Date();
        const currentYear = currentDate.getFullYear();
        const currentMonth = currentDate.getMonth() + 1;

        const yearInput = prompt('Enter year:', currentYear);
        if (!yearInput) return;

        if (!Formatters.validateYear(yearInput)) {
            alert('Please enter a valid year between 2000 and 2100');
            return;
        }

        const year = parseInt(yearInput, 10);
        const monthInput = prompt('Enter month (1-12):', currentMonth);
        if (!monthInput) return;

        if (!Formatters.validateMonth(monthInput)) {
            alert('Please enter a valid month between 1 and 12');
            return;
        }

        const month = parseInt(monthInput, 10);
        const monthKey = DataManager.generateMonthKey(year, month);
        const allMonths = DataManager.getAllMonths();
        const existingMonth = allMonths[monthKey];

        if (existingMonth) {
            if (confirm('A month for this period already exists. Do you want to open it instead?')) {
                window.location.href = `views/monthly-budget.html?month=${monthKey}`;
            }
            return;
        }

        await DataManager.createNewMonth(year, month);
        window.location.href = `views/monthly-budget.html?month=${monthKey}`;
    },

    /**
     * Delete a month
     * @param {string} monthKey - Month key to delete
     * @param {string} monthDisplayName - Display name of the month
     * @returns {void}
     */
    deleteMonth(monthKey, monthDisplayName) {
        const confirmMessage = `Are you sure you want to delete ${monthDisplayName}? This action cannot be undone.`;
        if (!confirm(confirmMessage)) {
            return;
        }

        const deletionSuccess = DataManager.deleteMonth(monthKey);

        if (deletionSuccess) {
            alert(`${monthDisplayName} has been deleted.`);
            this.loadOverviewData();
        } else {
            alert('Error deleting month. Please try again.');
        }
    },

    /**
     * Helper: Set element text content
     * @param {string} elementId - Element ID
     * @param {string} textContent - Text content to set
     * @returns {void}
     */
    setElementText(elementId, textContent) {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = textContent;
        }
    }
};

// Make LandingController available globally
window.LandingController = LandingController;

// Initialize when DOM is ready (if not already initialized by index.html)
document.addEventListener('DOMContentLoaded', () => {
    if (!window.landingControllerInitialized) {
        LandingController.init();
    }
});




// ===== Inline Scripts =====

// Inline script 1

        // Initialize with all months data if no months exist
        document.addEventListener('DOMContentLoaded', async function() {
            // Initialize settings first
            DataManager.initializeSettings();
            
            // Load months from files if localStorage is empty
            await InitialData.initializeIfEmpty();
            
            // Mark as initialized to prevent double initialization
            window.landingControllerInitialized = true;
            
            // Now initialize the LandingController
            if (window.LandingController) {
                await window.LandingController.init();
            }
        });
    
</script>
</body>
</html>

