<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Settings - Money Tracker</title>
    <style>/* ============================================================================
   MONEY TRACKER - MAIN STYLESHEET
   Imports all CSS modules in dependency order
   ============================================================================ */

/* Core Foundation */

/* ===== Imported from: variables.css ===== */
/* ============================================================================
   CSS VARIABLES (Design Tokens)
   ============================================================================ */

:root {
    /* ============================================
       COLOR PALETTE - Centralized Color Scheme
       ============================================ */
    
    /* Primary Colors */
    --primary-color: #b0b0b0;
    --primary-hover: #a0a0a0;
    --primary-focus-shadow: rgba(168, 168, 168, 0.3);
    
    /* Secondary Colors */
    --secondary-color: #b5b1aa;
    --secondary-hover: #c5bdbd;
    
    /* Status Colors */
    --success-color: #7bab8a;
    --success-hover: #4d6a57;
    --warning-color: #b5a58a;
    --danger-color: #b58a8a;
    --action-color: #7b9bab;
    --action-hover: #4d6a7a;
    --danger-hover: #7d4545;
    
    /* Background Colors */
    --background-color: #c5c3c3;
    --surface-color: #d0d0d0;
    --surface-color-darker: #c5c5c5;
    --surface-overlay-light: rgba(200, 196, 196, 0.98);
    --surface-overlay-medium: rgba(180, 180, 180, 1.0);
    --surface-overlay-section: rgba(180, 180, 180, 0.85);
    --surface-overlay-card: rgba(180, 180, 180, 0.75);
    --surface-overlay-card-landing: rgba(180, 180, 180, 0.80);
    --surface-overlay-button: rgba(255, 255, 255, 0.6);
    --surface-overlay-button-hover: rgba(255, 255, 255, 0.8);
    
    /* Text Colors */
    --text-primary: #1b1b1b;
    --text-secondary: #1a1a1a;
    --text-white: #f1f1f1;
    --text-black: #000000;
    --text-placeholder: #ffffff;
    --text-positive: #006c22;
    
    /* Border Colors */
    --border-color: #9d9d9d;
    --border-color-dark: #1f1f1f;
    --border-color-black: #000000;
    --border-print: #000000;
    
    /* Border Widths */
    --border-width-thin: 0.2px;
    --border-width-standard: 1px;
    --border-width-thick: 2px;
    
    /* Interactive States */
    --hover-overlay: rgba(255, 255, 255, 0.7);
    --landing-overlay: rgba(202, 202, 202, 0.5);
    --table-row-hover: #d3d3d3;
    
    /* Shadows */
    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.15);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.55);
    
    /* Spacing */
    --spacing-xs: 0.55rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 0.75rem;
    --spacing-lg: 1rem;
    --spacing-xl: 1.5rem;
    
    /* Spacing Multipliers (for reduced spacing) */
    --spacing-multiplier-reduced: 0.2;
    --spacing-multiplier-medium: 0.3;
    --spacing-multiplier-standard: 0.8;
    
    /* Typography */
    --line-height-base: 1.28;
    --line-height-reduced: 1.28;
    
    /* Layout */
    --border-radius: 0px;
    --border-radius-multiplier: 1;
    --transition: all 0.5s ease-in-out;
    
    /* Layout Dimensions */
    --max-width-content: 1200px;
    --viewport-spacing-top: 5vh;
    --month-title-padding-left: 5%;
    
    /* Background Images */
    --site-background: url('../reference/site_background_image.jpg');
}



/* ===== Imported from: reset.css ===== */
/* ============================================================================
   RESET & BASE STYLES
   ============================================================================ */

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html {
    font-size: 16px;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    line-height: var(--line-height-base);
    color: var(--text-primary);
    background-color: var(--background-color);
    background-image: var(--site-background);
    background-size: cover;
    background-position: center;
    background-attachment: fixed;
    background-repeat: no-repeat;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    position: relative;
}

body::after {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: var(--site-background);
    background-size: cover;
    background-position: center;
    background-attachment: fixed;
    background-repeat: no-repeat;
    z-index: -2;
    pointer-events: none;
}

body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--landing-overlay);
    z-index: -1;
    pointer-events: none;
}



/* ===== Imported from: typography.css ===== */
/* ============================================================================
   TYPOGRAPHY
   ============================================================================ */

/* Base Typography */
p, h1, h2, h3, h4, h5, h6, span, label, li {
    line-height: var(--line-height-reduced);
}

.section-title {
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: var(--spacing-xs);
    color: var(--text-primary);
}

h3.section-title {
    font-size: 1.25rem;
}

#month-title {
    padding-left: var(--month-title-padding-left);
}

.section-description {
    font-size: 1rem;
    color: var(--text-secondary);
    margin-bottom: var(--spacing-md);
    font-style: italic;
}

.hero-title {
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: var(--spacing-sm);
    color: var(--text-primary);
}

.hero-description {
    font-size: 1.25rem;
    color: var(--text-secondary);
    max-width: 600px;
    margin: 0 auto;
}



/* ===== Imported from: layout.css ===== */
/* ============================================================================
   LAYOUT COMPONENTS
   ============================================================================ */

/* Main Content */
main {
    flex: 1;
    max-width: var(--max-width-content);
    width: 100%;
    margin: 0 auto;
    padding: var(--spacing-sm) var(--spacing-sm);
}

/* Footer */
.main-footer {
    background-color: rgba(210, 210, 210, 0.85);
    border-top: var(--border-width-standard) solid var(--border-color);
    padding: var(--spacing-sm);
    text-align: center;
    color: var(--text-secondary);
    margin-top: auto;
}



/* Components */

/* ===== Imported from: components/navigation.css ===== */
/* ============================================================================
   NAVIGATION COMPONENT
   ============================================================================ */

/* Header - Consistent across all views (isolated from page-specific styles) */
.main-header {
    background-color: rgba(210, 210, 210, 0.85);
    border-bottom: var(--border-width-standard) solid var(--border-color);
    box-shadow: var(--shadow-sm);
    position: sticky;
    top: 0;
    z-index: 100;
    width: 100%;
    isolation: isolate;
    margin: 0;
    padding: 0;
    background-image: none;
}

body .main-header,
body.landing-page .main-header,
body:not(.landing-page) .main-header {
    background-color: rgba(210, 210, 210, 0.85);
    border-bottom: var(--border-width-standard) solid var(--border-color);
    box-shadow: var(--shadow-sm);
    background-image: none;
}

body .main-navigation,
body.landing-page .main-navigation,
body:not(.landing-page) .main-navigation {
    max-width: var(--max-width-content);
    margin: 0 auto;
    padding: var(--spacing-xs) var(--spacing-sm);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: nowrap;
    gap: var(--spacing-sm);
}

.main-navigation {
    max-width: var(--max-width-content);
    margin: 0 auto;
    padding: var(--spacing-xs) var(--spacing-sm);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: nowrap;
    gap: var(--spacing-sm);
}

.header-title-group {
    display: flex;
    align-items: center;
    flex-shrink: 1;
    gap: var(--spacing-xs);
    min-width: 0;
}

.header-title-group > .site-title {
    flex-shrink: 1;
    min-width: 0;
    white-space: nowrap;
    margin: 0;
    padding: 0;
}

.header-title-group > .hamburger-menu {
    flex-shrink: 0;
    margin: 0;
}

.main-navigation > .nav-list {
    flex: 0 1 auto;
    min-width: 0;
    margin-left: auto;
    flex-shrink: 1;
    white-space: nowrap;
}

@media (max-width: 1100px) {
    body .main-navigation,
    body.landing-page .main-navigation,
    body:not(.landing-page) .main-navigation,
    .main-navigation {
        flex-wrap: nowrap !important;
    }
    
    .header-title-group {
        flex-shrink: 1;
        min-width: 0;
    }
    
    .header-title-group > .site-title {
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 1rem;
    }
    
    .header-title-group > .hamburger-menu {
        display: none !important;
    }
    
    .main-navigation > .nav-list {
        flex-shrink: 1;
        min-width: 0;
        display: flex !important;
    }
    
    .nav-list {
        gap: var(--spacing-xs);
    }
    
    .nav-link {
        font-size: 0.9rem;
        padding: var(--spacing-xs);
    }
}

.site-title {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--text-primary);
    margin: 0;
    padding: 0;
    flex-shrink: 1;
    min-width: 0;
    white-space: nowrap;
    order: 1;
}

.nav-list {
    display: flex;
    list-style: none;
    gap: var(--spacing-md);
    flex-wrap: wrap;
    margin: 0;
    padding: 0;
    justify-content: flex-end;
    align-items: center;
}

.nav-link {
    text-decoration: none;
    color: var(--text-secondary);
    font-weight: 500;
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: 0px;
    transition: var(--transition);
    display: inline-block;
}

.nav-link:hover,
.nav-link.active,
.nav-link[aria-current="page"] {
    color: var(--text-primary);
    background-color: var(--hover-overlay);
}

.hamburger-menu {
    display: none;
    flex-direction: column;
    justify-content: space-around;
    width: 30px;
    height: 24px;
    background: none;
    border: none;
    cursor: pointer;
    padding: 0;
    margin-left: var(--spacing-sm);
    flex-shrink: 0;
    order: 2;
}

.hamburger-line {
    width: 100%;
    height: 3px;
    background-color: var(--text-primary);
    border-radius: 0px;
    transition: all 0.3s ease;
    transform-origin: center;
}

.hamburger-menu[aria-expanded="true"] .hamburger-line:nth-child(1) {
    transform: rotate(45deg) translate(6px, 6px);
}

.hamburger-menu[aria-expanded="true"] .hamburger-line:nth-child(2) {
    opacity: 0;
}

.hamburger-menu[aria-expanded="true"] .hamburger-line:nth-child(3) {
    transform: rotate(-45deg) translate(6px, -6px);
}

@media (max-width: 900px) {
    body .main-navigation,
    body.landing-page .main-navigation,
    body:not(.landing-page) .main-navigation,
    .main-navigation {
        position: relative;
        flex-wrap: nowrap !important;
        justify-content: flex-start !important;
        align-items: center;
        gap: var(--spacing-xs);
        padding: var(--spacing-xs) var(--spacing-sm);
    }
    
    .main-navigation > .site-title {
        flex: 0 1 auto !important;
        max-width: calc(100% - 40px) !important;
        margin-right: 0 !important;
    }
    
    .main-navigation > .hamburger-menu {
        flex: 0 0 auto !important;
        margin-left: var(--spacing-xs) !important;
    }

    .site-title {
        font-size: 1rem;
        flex-shrink: 1;
        min-width: 0;
        max-width: calc(100% - 40px);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        margin: 0;
        padding: 0;
        order: 1;
        line-height: 1.2;
    }

    .hamburger-menu {
        display: flex !important;
        width: 22px;
        height: 18px;
        margin-left: var(--spacing-xs);
        flex-shrink: 0;
        order: 2;
        padding: 0;
        min-width: 22px;
    }

    .hamburger-line {
        height: 2px;
    }
}

@media (max-width: 768px) {
    body .main-navigation,
    body.landing-page .main-navigation,
    body:not(.landing-page) .main-navigation,
    .main-navigation {
        position: relative;
        flex-wrap: nowrap !important;
        justify-content: flex-start !important;
        align-items: center;
        gap: var(--spacing-xs);
        padding: var(--spacing-xs) var(--spacing-sm);
    }

    .site-title {
        font-size: 0.9rem;
        flex-shrink: 1;
        min-width: 0;
        max-width: calc(100% - 35px);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        margin: 0;
        padding: 0;
        order: 1;
        line-height: 1.2;
    }

    .main-navigation > .nav-list {
        display: none !important;
    }

    .header-title-group > .hamburger-menu {
        display: flex !important;
        width: 22px;
        height: 18px;
        flex-shrink: 0;
        padding: 0;
        min-width: 22px;
        margin: 0;
    }
    
    .hamburger-menu {
        display: flex !important;
    }

    .hamburger-line {
        height: 2px;
    }

    .nav-list {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background-color: rgba(210, 210, 210, 0.85);
        border: var(--border-width-thin) solid var(--border-color-black);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-md);
        flex-direction: column;
        gap: 0;
        padding: var(--spacing-sm) 0;
        transform: translateY(-10px);
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        z-index: 1000;
        width: 100%;
        flex: 0 0 auto;
        order: 3;
        display: flex !important;
    }

    .main-navigation > .nav-list.nav-open {
        display: flex !important;
        transform: translateY(0);
        opacity: 1;
        visibility: visible;
    }
    
    .nav-list.nav-open {
        transform: translateY(0);
        opacity: 1;
        visibility: visible;
    }

    .nav-list li {
        width: 100%;
        text-align: center;
        border-bottom: 1px solid var(--border-color);
    }

    .nav-list li:last-child {
        border-bottom: none;
    }

    .nav-link {
        display: block;
        padding: var(--spacing-sm) var(--spacing-md);
        width: 100%;
        text-align: center;
        border-radius: 0;
    }

    .nav-link:hover,
    .nav-link.active,
    .nav-link[aria-current="page"] {
        background-color: var(--hover-overlay);
    }
}



/* ===== Imported from: components/forms.css ===== */
/* ============================================================================
   FORM COMPONENTS
   ============================================================================ */

.form-section {
    background-color: rgba(220, 220, 220, 0.85);
    border: var(--border-width-standard) solid var(--border-color-dark);
    border-radius: calc(var(--border-radius) * var(--border-radius-multiplier));
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-md);
    box-shadow: var(--shadow-sm);
}

.working-section {
    border-radius: 0px;
}

.months-comparison-section {
    background-color: rgba(220, 220, 220, 0.85);
    border-radius: calc(var(--border-radius) * var(--border-radius-multiplier));
}

.form-group {
    margin-bottom: var(--spacing-sm);
}

.form-label {
    display: block;
    font-weight: 500;
    margin-bottom: var(--spacing-xs);
    color: var(--text-primary);
}

.form-input,
.form-select,
.form-textarea {
    width: 100%;
    padding: var(--spacing-xs) var(--spacing-sm);
    border: var(--border-width-standard) solid var(--border-color);
    border-radius: var(--border-radius);
    font-size: 1rem;
    transition: var(--transition);
    font-family: inherit;
    background-color: rgba(230, 230, 230, 0.85);
    color: var(--text-primary);
}

.form-input:focus,
.form-select:focus,
.form-textarea:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px var(--primary-focus-shadow);
}

#copy-income-from-month,
#copy-fixed-costs-from-month,
#copy-variable-costs-from-month,
#copy-unplanned-from-month {
    width: auto !important;
    min-width: fit-content;
}

.form-textarea {
    resize: vertical;
    min-height: 100px;
}

input:not([type="checkbox"]):not([type="radio"]),
select,
textarea {
    background-color: rgba(230, 230, 230, 0.85);
    color: var(--text-primary);
    border-color: var(--border-color);
}

input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

input[type="number"] {
    -moz-appearance: textfield;
}

input::placeholder,
textarea::placeholder,
select::placeholder,
input::-webkit-input-placeholder,
textarea::-webkit-input-placeholder,
select::-webkit-input-placeholder,
input::-moz-placeholder,
textarea::-moz-placeholder,
select::-moz-placeholder,
input:-ms-input-placeholder,
textarea:-ms-input-placeholder,
select:-ms-input-placeholder {
    color: var(--text-placeholder);
    opacity: 1;
}



/* ===== Imported from: components/tables.css ===== */
/* ============================================================================
   TABLE COMPONENTS
   ============================================================================ */

table:not(.data-table) {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    background-color: rgba(216, 216, 216, 0.85);
    border-radius: var(--border-radius);
    overflow: hidden;
    box-shadow: var(--shadow-sm);
    margin-bottom: var(--spacing-lg);
    border: var(--border-width-thin) solid var(--border-color-black);
}

table:not(.data-table) th,
table:not(.data-table) td {
    line-height: var(--line-height-reduced);
    padding-top: calc(var(--spacing-xs) * var(--spacing-multiplier-reduced));
    padding-bottom: calc(var(--spacing-xs) * var(--spacing-multiplier-reduced));
    padding-left: var(--spacing-sm);
    padding-right: var(--spacing-sm);
    background-color: rgba(221, 221, 221, 0.85);
    border: var(--border-width-thin) solid var(--border-color-black);
}

table:not(.data-table) th:first-child,
table:not(.data-table) td:first-child {
    border-left: var(--border-width-thin) solid var(--border-color-black);
}

table:not(.data-table) thead th {
    border-top: var(--border-width-thin) solid var(--border-color-black);
}

table:not(.data-table) thead th:last-child {
    border-right: var(--border-width-thin) solid var(--border-color-black);
}

table:not(.data-table) tbody tr:last-child td,
table:not(.data-table) tfoot tr:last-child td {
    border-bottom: var(--border-width-thin) solid var(--border-color-black);
}

table:not(.data-table) tbody tr:last-child td:last-child {
    border-right: var(--border-width-thin) solid var(--border-color-black);
}

table:not(.data-table) tfoot tr:last-child td:last-child {
    border-right: var(--border-width-thin) solid var(--border-color-black);
}

.data-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    background-color: rgba(213, 213, 213, 0.85);
    border-radius: var(--border-radius);
    overflow: hidden;
    box-shadow: var(--shadow-sm);
    margin-bottom: var(--spacing-lg);
    border: var(--border-width-thin) solid var(--border-color-black);
}

.data-table th {
    background-color: rgba(208, 208, 208, 0.85);
    padding: calc(var(--spacing-xs) * var(--spacing-multiplier-reduced)) var(--spacing-sm);
    text-align: left;
    font-weight: 600;
    color: var(--text-primary);
    border: var(--border-width-thin) solid var(--border-color-black);
    white-space: nowrap;
}

.data-table th:first-child {
    border-left: var(--border-width-thin) solid var(--border-color-black);
}

.data-table thead th {
    border-top: var(--border-width-thin) solid var(--border-color-black);
}

.data-table thead th:last-child {
    border-right: var(--border-width-thin) solid var(--border-color-black);
}

.data-table td {
    padding: calc(var(--spacing-xs) * var(--spacing-multiplier-medium)) var(--spacing-sm);
    border: var(--border-width-thin) solid var(--border-color-black);
    background-color: rgba(221, 221, 221, 0.85);
    white-space: nowrap;
}

.data-table td:first-child {
    border-left: var(--border-width-thin) solid var(--border-color-black);
}

.data-table tbody tr:last-child td,
.data-table tfoot tr:last-child td {
    border-bottom: var(--border-width-thin) solid var(--border-color-black);
}

.data-table tbody tr:last-child td:last-child {
    border-right: var(--border-width-thin) solid var(--border-color-black);
}

.data-table tfoot tr:last-child td:last-child {
    border-right: var(--border-width-thin) solid var(--border-color-black);
}

.data-table tr {
    background-color: rgba(221, 221, 221, 0.85);
}

.data-table tr:hover {
    background-color: rgba(208, 208, 208, 0.85);
}

.data-table input[type="number"],
.data-table input[type="text"],
.data-table input[type="date"],
.data-table select,
.data-table textarea {
    width: 100%;
    padding: var(--spacing-xs);
    border: var(--border-width-standard) solid var(--border-color);
    border-radius: 0px;
    font-size: 0.875rem;
    background-color: #ffffff;
    color: var(--text-primary);
}

.data-table input::placeholder,
.data-table textarea::placeholder,
.data-table input::-webkit-input-placeholder,
.data-table textarea::-webkit-input-placeholder,
.data-table input::-moz-placeholder,
.data-table textarea::-moz-placeholder,
.data-table input:-ms-input-placeholder,
.data-table textarea:-ms-input-placeholder {
    color: var(--text-placeholder);
    opacity: 1;
}

.data-table .total-row {
    font-weight: 600;
    background-color: rgba(200, 200, 200, 0.85);
}

#weekly-breakdown-table {
    border-radius: 0px;
    table-layout: auto;
    width: 100%;
}

#weekly-breakdown-table th,
#weekly-breakdown-table td {
    white-space: nowrap;
}

#weekly-breakdown-table th:first-child,
#weekly-breakdown-table td:first-child {
    width: 100px;
    min-width: 80px;
    max-width: 120px;
}

#weekly-breakdown-table th:nth-child(2),
#weekly-breakdown-table td:nth-child(2) {
    width: auto;
    min-width: 180px;
    max-width: 350px;
}

#weekly-breakdown-table th:nth-child(n+3):not(:nth-last-child(2)):not(:nth-last-child(3)):not(:last-child),
#weekly-breakdown-table td:nth-child(n+3):not(:nth-last-child(2)):not(:nth-last-child(3)):not(:last-child) {
    width: auto;
    min-width: 150px;
    max-width: 250px;
}

#weekly-breakdown-table th:nth-last-child(3),
#weekly-breakdown-table td:nth-last-child(3) {
    width: auto;
    min-width: 100px;
    max-width: 150px;
}

#weekly-breakdown-table th:nth-last-child(2),
#weekly-breakdown-table td:nth-last-child(2) {
    width: auto;
    min-width: 100px;
    max-width: 150px;
}

#weekly-breakdown-table th:last-child,
#weekly-breakdown-table td:last-child {
    width: 40px;
    min-width: 40px;
    max-width: 40px;
}

#weekly-breakdown-table .delete-column-header {
    padding: calc(var(--spacing-xs) * var(--spacing-multiplier-reduced)) var(--spacing-sm);
    border: none !important;
    background-color: transparent !important;
    text-align: center;
}

#weekly-breakdown-table td:last-child {
    padding: calc(var(--spacing-xs) * var(--spacing-multiplier-medium)) var(--spacing-sm);
    border: none !important;
    background-color: transparent !important;
    text-align: center;
}

#weekly-breakdown-tbody input,
#weekly-breakdown-tbody textarea {
    border-color: var(--border-color-black);
}

.data-table:not(#weekly-breakdown-table) .delete-column-header {
    width: 40px;
    min-width: 40px;
    max-width: 40px;
    padding: calc(var(--spacing-xs) * var(--spacing-multiplier-reduced)) var(--spacing-sm);
    border: none !important;
    background-color: transparent !important;
    text-align: center;
}

#months-comparison-table .delete-column-header {
    width: auto;
    min-width: 120px;
    max-width: 150px;
}

#months-comparison-table td:last-child {
    width: auto;
    min-width: 120px;
    max-width: 150px;
    padding: calc(var(--spacing-xs) * var(--spacing-multiplier-medium)) var(--spacing-sm);
    padding: calc(var(--spacing-xs) * var(--spacing-multiplier-medium)) var(--spacing-sm);
}

.data-table:not(#weekly-breakdown-table) td:last-child:has(.delete-row-x) {
    width: 40px;
    min-width: 40px;
    max-width: 40px;
    padding: calc(var(--spacing-xs) * var(--spacing-multiplier-medium)) var(--spacing-sm);
    border: none !important;
    background-color: transparent !important;
    text-align: center;
}

.data-table tbody tr:last-child td:last-child,
.data-table tfoot tr:last-child td:last-child,
.data-table .total-row td:last-child {
    border: none !important;
    background-color: rgba(221, 221, 221, 0.85) !important;
}

#weekly-breakdown-table tbody tr:last-child td:last-child,
#weekly-breakdown-table .total-row td:last-child {
    border: none !important;
    background-color: rgba(221, 221, 221, 0.85) !important;
}

.delete-row-x {
    cursor: pointer;
    color: var(--danger-color);
    font-size: 1.4rem;
    font-weight: bold;
    padding: 0;
    line-height: 1;
    user-select: none;
    background: transparent;
    border: none;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto;
    border-radius: 0;
    transition: background-color 0.2s ease, color 0.2s ease;
}

.delete-row-x:hover {
    color: var(--danger-hover);
    background-color: rgba(181, 138, 138, 0.2);
}

.delete-row-x:active {
    transform: scale(0.9);
}

.data-table td:last-child:has(.btn):has(.delete-row-x) {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: calc(var(--spacing-xs) * var(--spacing-multiplier-medium)) var(--spacing-sm);
    width: auto;
    min-width: 120px;
    max-width: 150px;
}

#months-comparison-table td:last-child:has(.btn):has(.delete-row-x) {
    min-width: 120px;
    max-width: 150px;
}

.data-table td:last-child:has(.btn):has(.delete-row-x) .delete-row-x {
    margin-left: auto;
}

/* ============================================================================
   DATE AND CARD COLUMN MINIMUM WIDTHS
   Ensures these columns never shrink narrower than their content
   ============================================================================ */

/* Date inputs - compact width for date text (e.g., "31st") */
.data-table .income-date,
.data-table .fixed-cost-date,
.data-table .unplanned-date {
    min-width: 4em;
    width: 5em;
}

/* Card inputs - compact width */
.data-table .fixed-cost-card,
.data-table .unplanned-card {
    min-width: 5em;
    width: 7em;
}



/* ===== Imported from: components/buttons.css ===== */
/* ============================================================================
   BUTTON COMPONENTS
   ============================================================================ */

.btn {
    padding: 0.3rem 0.5rem;
    border: var(--border-width-standard) solid var(--border-color-black);
    border-radius: 0px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
    text-align: center;
    min-height: 1.85rem;
    height: 1.85rem;
    box-sizing: border-box;
    line-height: 1;
    white-space: nowrap;
}

.btn-primary {
    background-color: var(--primary-color);
    color: var(--text-white);
}

.btn-primary:hover {
    background-color: var(--primary-hover);
}

.btn-secondary {
    background-color: rgba(210, 210, 210, 0.85);
    color: var(--text-black);
}

.btn-secondary:hover {
    background-color: rgba(200, 200, 200, 0.85);
    color: var(--text-black);
}

.btn-danger {
    background-color: var(--danger-color);
    color: var(--text-white);
}

.btn-danger:hover {
    background-color: var(--danger-hover);
}

.btn-success {
    background-color: var(--success-color);
    color: var(--text-white);
}

.btn-success:hover {
    background-color: var(--success-hover);
}

.btn-action {
    background-color: var(--action-color);
    color: var(--text-white);
}

.btn-action:hover {
    background-color: var(--action-hover);
}

.btn-sm {
    padding: 0.55rem 0.75rem;
    font-size: 0.875rem;
}

#export-format-select {
    background-color: var(--action-color) !important;
    color: var(--text-white) !important;
    border: var(--border-width-standard) solid var(--border-color-black) !important;
    border-radius: var(--border-radius) !important;
    padding: 0.5rem 1rem !important;
    cursor: pointer;
    font-size: 0.9rem;
}

#export-format-select:hover {
    background-color: var(--action-hover) !important;
    border: var(--border-width-standard) solid var(--border-color-black) !important;
}

#export-format-select option {
    background-color: var(--action-color);
    color: var(--text-white);
}



/* ===== Imported from: components/cards.css ===== */
/* ============================================================================
   CARD COMPONENTS
   ============================================================================ */

.view-card {
    background-color: rgba(220, 220, 220, 0.85) !important;
    border: var(--border-width-standard) solid var(--border-color) !important;
    border-radius: var(--border-radius) !important;
    padding: var(--spacing-md) !important;
    box-shadow: var(--shadow-md) !important;
    backdrop-filter: blur(10px);
    transition: var(--transition);
    cursor: pointer;
    color: inherit;
    text-align: left;
    display: block;
    width: 100%;
    text-decoration: none !important;
}

body.landing-page .view-card {
    background-color: rgba(225, 225, 225, 0.85) !important;
    box-shadow: var(--shadow-lg) !important;
}

.view-card:hover,
.view-card:focus {
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
    outline: var(--border-width-thick) solid var(--primary-color);
    outline-offset: var(--border-width-thick);
    background-color: rgba(210, 210, 210, 0.85);
}

body.landing-page .view-card:hover,
body.landing-page .view-card:focus {
    background-color: rgba(210, 210, 210, 0.85);
}

.view-card-icon {
    font-size: 3rem;
    margin-bottom: var(--spacing-sm);
    display: block;
}

.view-card-title {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: var(--spacing-xs);
    color: var(--text-primary);
    line-height: var(--line-height-reduced);
}

.view-card-description {
    color: var(--text-secondary);
    margin-bottom: var(--spacing-sm);
    line-height: var(--line-height-reduced);
}

.summary-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--spacing-sm);
}

.summary-card {
    background-color: rgba(215, 215, 215, 0.85);
    border: var(--border-width-standard) solid var(--border-color);
    border-radius: calc(var(--border-radius) * var(--border-radius-multiplier));
    padding: var(--spacing-sm);
    box-shadow: var(--shadow-sm);
}

.summary-card-title {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--text-secondary);
    margin-bottom: var(--spacing-xs);
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.summary-card-value {
    font-size: 2rem;
    font-weight: 700;
    color: var(--text-primary);
}

.summary-card-value.positive {
    color: var(--text-positive);
}

.summary-card-value.negative {
    color: var(--danger-color);
}

.month-item {
    background-color: rgba(220, 220, 220, 0.85);
    border: var(--border-width-standard) solid var(--border-color);
    border-radius: var(--border-radius);
    padding: var(--spacing-md);
    text-align: center;
    cursor: pointer;
    transition: var(--transition);
    text-decoration: none;
    color: var(--text-primary);
    display: block;
    box-shadow: var(--shadow-md);
    backdrop-filter: blur(10px);
}

.month-item:hover,
.month-item:focus {
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
    outline: var(--border-width-thick) solid var(--primary-color);
    outline-offset: var(--border-width-thick);
}

.month-item-title {
    font-weight: 600;
    margin-bottom: var(--spacing-xs);
}

.month-item-date {
    font-size: 0.875rem;
    color: var(--text-secondary);
}

.action-button {
    background-color: rgba(210, 210, 210, 0.85);
    color: var(--text-primary);
    border: var(--border-width-standard) solid var(--border-color-black);
    border-radius: var(--border-radius);
    padding: var(--spacing-md);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: var(--spacing-xs);
    box-shadow: var(--shadow-md);
    backdrop-filter: blur(10px);
    width: auto;
    white-space: nowrap;
}

.action-button:hover,
.action-button:focus {
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
    outline: var(--border-width-thick) solid var(--primary-color);
    outline-offset: var(--border-width-thick);
}

.action-button:active {
    transform: translateY(0);
}

.action-icon {
    font-size: 1.25rem;
}



/* Views */

/* ===== Imported from: views/landing.css ===== */
/* ============================================================================
   LANDING PAGE STYLES
   ============================================================================ */

.hero-section {
    background-color: rgba(225, 225, 225, 0.85);
    border: var(--border-width-standard) solid var(--border-color-dark);
    border-radius: 0px;
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-md);
    text-align: center;
}

.summary-section {
    margin-bottom: var(--spacing-md);
}

.views-section {
    margin-bottom: var(--spacing-md);
}

.views-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: var(--spacing-sm);
}

.months-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: var(--spacing-xs);
}

.quick-actions-section {
    margin-bottom: var(--spacing-md);
}

.actions-grid {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-sm);
}

@media (max-width: 768px) {
    .views-grid {
        grid-template-columns: 1fr;
    }
}

@media (max-width: 480px) {
    .view-card {
        padding: var(--spacing-md);
        background-color: rgba(220, 220, 220, 0.85);
    }
    
    body.landing-page .view-card {
        background-color: rgba(225, 225, 225, 0.85);
    }
}

.months-comparison-section {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
}

#months-comparison-table {
    min-width: 800px;
    width: 100%;
}

@media (max-width: 768px) {
    .months-comparison-section {
        overflow-x: auto;
    }
    
    #months-comparison-table {
        min-width: 700px;
    }
    
    #months-comparison-table th,
    #months-comparison-table td {
        white-space: nowrap;
        font-size: 0.875rem;
        padding: calc(var(--spacing-xs) * var(--spacing-multiplier-reduced)) var(--spacing-xs);
    }
}



/* ===== Imported from: views/monthly-budget.css ===== */
/* ============================================================================
   MONTHLY BUDGET PAGE STYLES
   ============================================================================ */

/* Prevent text wrapping in all table cells - ensures multi-word names stay on one line */
.data-table th,
.data-table td {
    white-space: nowrap;
}

#summary-table th,
#summary-table td {
    white-space: nowrap;
}

.month-selector-section {
    background-color: rgba(225, 225, 225, 0.85);
    border-radius: 0px;
}

.month-header-container {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
    padding: var(--spacing-md);
}

.month-title-wrapper {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex: 1;
    min-width: 0;
}

.month-title {
    font-size: 1.75rem;
    font-weight: 600;
    margin: 0;
    color: var(--text-primary);
    white-space: nowrap;
    flex-shrink: 0;
}

.month-selector-compact {
    padding: 0.5rem 1rem;
    border: var(--border-width-standard) solid var(--border-color-black);
    border-radius: 0px;
    background-color: var(--bg-input);
    color: var(--text-primary);
    font-size: 0.95rem;
    font-weight: 500;
    cursor: pointer;
    min-width: 180px;
    max-width: 220px;
}

.month-selector-compact:hover {
    background-color: var(--bg-input-hover, rgba(240, 240, 240, 0.9));
}

.month-selector-compact:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
}

.month-selector-wrapper {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex: 1;
    min-width: 0;
}

.month-selector-wrapper .form-label {
    margin: 0;
    white-space: nowrap;
    font-weight: 500;
}

.month-selector-wrapper .form-select {
    flex: 1;
    min-width: 200px;
    max-width: 300px;
}

.month-buttons-container {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    flex-shrink: 0;
    flex-wrap: nowrap;
}

.create-month-btn {
    flex-shrink: 1;
    white-space: nowrap;
    min-width: 0;
}

#month-content > section {
    background-color: rgba(220, 220, 220, 0.85);
    border-radius: calc(var(--border-radius) * var(--border-radius-multiplier));
}

@media (max-width: 1024px) {
    .month-header-container {
        gap: 0.75rem;
    }
}

@media (max-width: 768px) {
    .month-header-container {
        flex-direction: column;
        align-items: stretch;
        gap: 0.75rem;
        padding: var(--spacing-sm);
    }
    
    .month-title-wrapper {
        flex-wrap: nowrap;
        gap: 0.5rem;
    }
    
    .month-title {
        font-size: 1.25rem;
    }
    
    .month-selector-compact {
        min-width: 140px;
        max-width: none;
        flex: 1;
        font-size: 0.85rem;
        padding: 0.4rem 0.75rem;
    }
    
    .month-selector-wrapper {
        flex-wrap: nowrap;
        gap: 0.5rem;
    }
    
    .month-selector-wrapper .form-label {
        font-size: 0.9rem;
    }
    
    .month-selector-wrapper .form-select {
        min-width: 140px;
        max-width: none;
        flex: 1;
    }
    
    .month-buttons-container {
        justify-content: center;
    }
    
    .create-month-btn,
    #load-example-button {
        flex: 1 1 auto;
        min-width: 0;
        font-size: 0.85rem;
        padding: 0.5rem 0.75rem;
    }

    .section-actions-container {
        flex-wrap: wrap;
    }

    .copy-month-select {
        max-width: 200px;
        min-width: 150px;
    }

    .data-table th,
    .data-table td {
        white-space: nowrap;
    }

    .data-table input[type="number"],
    .data-table input[type="text"],
    .data-table input[type="date"],
    .data-table select,
    .data-table textarea {
        font-size: 0.8rem;
        padding: calc(var(--spacing-xs) * 0.85);
    }
}

@media (max-width: 480px) {
    .month-title {
        font-size: 1rem;
    }
    
    .month-selector-compact {
        min-width: 100px;
        font-size: 0.8rem;
        padding: 0.35rem 0.5rem;
    }
    
    .month-selector-wrapper .form-label {
        font-size: 0.85rem;
    }
    
    .month-selector-wrapper .form-select {
        min-width: 100px;
        font-size: 0.85rem;
    }
    
    .create-month-btn,
    #load-example-button {
        font-size: 0.75rem;
        padding: 0.4rem 0.5rem;
    }

    .section-actions-container {
        flex-direction: column !important;
        align-items: stretch !important;
        width: 100% !important;
        text-align: left !important;
        justify-content: flex-start !important;
        gap: 0.5rem !important;
    }

    .copy-month-select {
        width: 100% !important;
        max-width: 100% !important;
        min-width: 0 !important;
    }

    .section-actions-container button {
        width: 100%;
    }

    .data-table th,
    .data-table td {
        white-space: nowrap;
    }

    .data-table input[type="number"],
    .data-table input[type="text"],
    .data-table input[type="date"],
    .data-table select,
    .data-table textarea {
        font-size: 0.75rem;
        padding: calc(var(--spacing-xs) * 0.75);
    }
}

/* ============================================================================
   HELP BUTTON STYLES
   ============================================================================ */

.help-button {
    width: 1.25rem;
    height: 1.25rem;
    min-width: 1.25rem;
    min-height: 1.25rem;
    padding: 0;
    border: var(--border-width-standard) solid var(--border-color-black);
    border-radius: 50%;
    background-color: var(--action-color);
    color: var(--text-white);
    font-size: 0.75rem;
    font-weight: 600;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
    transition: var(--transition);
    flex-shrink: 0;
}

.help-button:hover {
    background-color: var(--action-hover);
    transform: scale(1.1);
}

.help-button:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
}

/* ============================================================================
   HELP MODAL STYLES
   ============================================================================ */

.help-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.help-modal-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    cursor: pointer;
}

.help-modal-content {
    position: relative;
    background-color: var(--surface-color);
    border: var(--border-width-standard) solid var(--border-color-black);
    border-radius: calc(var(--border-radius) * var(--border-radius-multiplier));
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    z-index: 1001;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
}

.help-modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--spacing-md);
    border-bottom: var(--border-width-standard) solid var(--border-color-black);
}

.help-modal-title {
    margin: 0;
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--text-primary);
}

.help-modal-close {
    width: 2rem;
    height: 2rem;
    min-width: 2rem;
    min-height: 2rem;
    padding: 0;
    border: var(--border-width-standard) solid var(--border-color-black);
    border-radius: 0px;
    background-color: var(--danger-color);
    color: var(--text-white);
    font-size: 1.5rem;
    font-weight: 600;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
    transition: var(--transition);
}

.help-modal-close:hover {
    background-color: var(--danger-hover);
}

.help-modal-close:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
}

.help-modal-body {
    padding: var(--spacing-md);
    overflow-y: auto;
    color: var(--text-primary);
    line-height: 1.6;
}

.help-modal-body p {
    margin: 0 0 1rem 0;
}

.help-modal-body p:last-child {
    margin-bottom: 0;
}

.help-modal-body ul {
    margin: 0.5rem 0 1rem 1.5rem;
    padding: 0;
}

.help-modal-body li {
    margin: 0.25rem 0;
}

.help-modal-body code {
    background-color: rgba(0, 0, 0, 0.1);
    padding: 0.125rem 0.25rem;
    border-radius: 2px;
    font-family: monospace;
    font-size: 0.9em;
}

.help-modal-body strong {
    font-weight: 600;
}

.help-modal-body table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
    font-size: 0.9rem;
}

.help-modal-body table thead tr {
    background-color: rgba(0, 0, 0, 0.1);
}

.help-modal-body table th {
    padding: 0.5rem;
    border: 1px solid var(--border-color-black);
    text-align: left;
    font-weight: 600;
}

.help-modal-body table td {
    padding: 0.5rem;
    border: 1px solid var(--border-color-black);
    vertical-align: top;
}

.help-modal-body table tbody tr:nth-child(even) {
    background-color: rgba(0, 0, 0, 0.05);
}

.help-modal-body table tbody tr:hover {
    background-color: rgba(0, 0, 0, 0.08);
}

@media (max-width: 768px) {
    .help-modal-content {
        width: 95%;
        max-height: 90vh;
    }

    .help-modal-header {
        padding: var(--spacing-sm);
    }

    .help-modal-body {
        padding: var(--spacing-sm);
    }
}



/* ===== Imported from: views/overview.css ===== */
/* ============================================================================
   OVERVIEW PAGE STYLES
   ============================================================================ */

.summary-section {
    background-color: rgba(215, 215, 215, 0.85);
}

.trend-item {
    background-color: rgba(220, 220, 220, 0.85);
    border: var(--border-width-standard) solid var(--border-color);
    border-radius: var(--border-radius);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-md);
}

.trend-item h3 {
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: var(--spacing-xs);
    color: var(--text-primary);
}

.trend-item p {
    margin: var(--spacing-xs) 0;
    color: var(--text-secondary);
}

@media (max-width: 768px) {
    .summary-grid {
        display: table;
        width: 100%;
        border-collapse: collapse;
        background-color: rgba(215, 215, 215, 0.85);
        border: var(--border-width-standard) solid var(--border-color);
        border-radius: calc(var(--border-radius) * var(--border-radius-multiplier));
        overflow: hidden;
    }

    .summary-card {
        display: table-row;
        background-color: transparent;
        border: none;
        border-bottom: var(--border-width-thin) solid var(--border-color);
        padding: 0;
        box-shadow: none;
    }

    .summary-card:last-child {
        border-bottom: none;
    }

    .summary-card:nth-child(even) {
        background-color: rgba(221, 221, 221, 0.85);
    }

    .summary-card-title {
        display: table-cell;
        padding: var(--spacing-sm) var(--spacing-md);
        font-size: 0.875rem;
        font-weight: 600;
        text-transform: none;
        letter-spacing: normal;
        color: var(--text-primary);
        vertical-align: middle;
        text-align: left;
    }

    .summary-card-value {
        display: table-cell;
        padding: var(--spacing-sm) var(--spacing-md);
        font-size: 1rem;
        font-weight: 600;
        text-align: right;
        vertical-align: middle;
        white-space: nowrap;
    }
}



/* ===== Imported from: views/pots.css ===== */
/* ============================================================================
   POTS PAGE STYLES
   ============================================================================ */

.pots-main > section {
    background-color: rgba(220, 220, 220, 0.85);
    border-radius: calc(var(--border-radius) * var(--border-radius-multiplier));
}

.pots-main table {
    /* Inherits all styles from .data-table */
}

.hero-section-pots {
    background-color: rgba(220, 220, 220, 0.85);
}

.pots-main .summary-grid {
    display: flex;
    justify-content: center;
    gap: var(--spacing-md);
    flex-wrap: wrap;
}

.pots-main .summary-card {
    flex: 0 1 auto;
    min-width: 200px;
    max-width: 300px;
}



/* ===== Imported from: views/settings.css ===== */
/* ============================================================================
   SETTINGS PAGE STYLES
   ============================================================================ */

.settings-main {
    max-width: 600px;
    margin: 0 auto;
    padding: var(--spacing-md);
    padding-top: 5rem;
}

.settings-section {
    margin-bottom: var(--spacing-md);
}

.settings-row {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    flex-wrap: wrap;
    margin-bottom: var(--spacing-sm);
}

.settings-row .form-label {
    margin-bottom: 0;
    min-width: 80px;
    flex-shrink: 0;
}

.settings-row .form-select,
.settings-row .form-input {
    flex: 1;
    min-width: 150px;
    max-width: 300px;
}

.settings-row .btn {
    flex-shrink: 0;
}

.settings-row-full {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    flex-wrap: wrap;
    margin-bottom: var(--spacing-sm);
}

.settings-inline-group {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    flex-wrap: wrap;
}

.settings-inline-group .form-label {
    margin-bottom: 0;
}

.settings-inline-group .form-input,
.settings-inline-group .form-select {
    width: auto;
    min-width: 100px;
}

.settings-divider {
    border-top: 1px solid var(--border-color);
    margin: var(--spacing-sm) 0;
    padding-top: var(--spacing-sm);
}

.settings-status {
    margin-top: var(--spacing-xs);
    font-size: 0.875rem;
}

@media (max-width: 480px) {
    .settings-row {
        flex-direction: column;
        align-items: stretch;
    }
    
    .settings-row .form-label {
        min-width: auto;
    }
    
    .settings-row .form-select,
    .settings-row .form-input {
        max-width: none;
    }
    
    .settings-inline-group {
        flex-direction: column;
        align-items: stretch;
    }
    
    .settings-inline-group .form-input,
    .settings-inline-group .form-select {
        width: 100%;
    }
}



/* Utilities & Responsive */

/* ===== Imported from: utilities.css ===== */
/* ============================================================================
   UTILITY CLASSES
   ============================================================================ */

.loading-message,
.empty-message {
    text-align: center;
    color: var(--text-secondary);
    padding: var(--spacing-md);
    font-style: italic;
}



/* ===== Imported from: responsive.css ===== */
/* ============================================================================
   RESPONSIVE DESIGN
   ============================================================================ */

@media (max-width: 768px) {
    .hero-title {
        font-size: 2rem;
    }

    .hero-description {
        font-size: 1rem;
    }

    .data-table {
        font-size: 0.875rem;
        display: block;
        overflow-x: auto;
    }
}

@media (max-width: 480px) {
    .hero-title {
        font-size: 1.75rem;
    }

    .section-title {
        font-size: 1.15rem;
    }
    
    h3.section-title {
        font-size: 1.15rem;
    }

    .form-section {
        padding: var(--spacing-md);
    }
}



/* ===== Imported from: print.css ===== */
/* ============================================================================
   PRINT STYLES
   ============================================================================ */

@media print {
    .main-header,
    .main-footer,
    .action-button,
    .btn {
        display: none;
    }

    main {
        max-width: 100%;
        padding: 0;
    }

    .view-card,
    .summary-card,
    .form-section {
        box-shadow: none;
        border: var(--border-width-standard) solid var(--border-print);
        page-break-inside: avoid;
    }
}


</style>
    <link rel="icon" href="data:,">
</head>
<body>
    <!-- Header will be injected by Header.js -->

    <main class="settings-main" role="main">

        <section class="settings-section form-section">
            <h2 class="section-title">General</h2>

            <div class="settings-row">
                <label for="currency-select" class="form-label">Currency:</label>
                <select id="currency-select" class="form-select">
                    <option value=""> (GBP)</option>
                    <option value="$">$ (USD)</option>
                    <option value=""> (EUR)</option>
                    <option value=""> (JPY)</option>
                    <option value=""> (INR)</option>
                    <option value="A$">A$ (AUD)</option>
                    <option value="C$">C$ (CAD)</option>
                    <option value="CHF">CHF</option>
                    <option value="NZ$">NZ$ (NZD)</option>
                    <option value="R">R (ZAR)</option>
                </select>
                <div id="currency-status" class="settings-status"></div>
            </div>

            <div class="settings-row">
                <label class="form-label">Cache:</label>
                <button id="clear-all-data-button" class="btn btn-danger">Clear All Cached Data</button>
            </div>
        </section>

        <section class="settings-section form-section">
            <h2 class="section-title">Import</h2>

            <div class="settings-row">
                <label for="file-input" class="form-label">Files:</label>
                <input type="file" id="file-input" class="form-input" accept=".json,.csv,.html" multiple style="max-width: none;">
            </div>

            <div id="year-input-group" class="settings-inline-group" style="display: none;">
                <label for="import-year" class="form-label">Year:</label>
                <input type="number" id="import-year" class="form-input" value="2025" min="2000" max="2100" style="width: 100px;">
                <button id="import-button" class="btn btn-action">Import</button>
            </div>

            <div id="import-status" class="settings-status"></div>
        </section>

        <section class="settings-section form-section">
            <h2 class="section-title">Export & Delete</h2>
            
            <div class="settings-row">
                <label for="month-selector" class="form-label">Month:</label>
                <select id="month-selector" class="form-select">
                    <option value="">Select month...</option>
                </select>
            </div>

            <div class="settings-row">
                <label for="export-format-select" class="form-label">Format:</label>
                <select id="export-format-select" class="form-select" style="max-width: 120px;">
                    <option value="json">JSON</option>
                    <option value="csv">CSV</option>
                    <option value="html">HTML</option>
                </select>
                <button id="export-button" class="btn btn-action">Export</button>
                <button id="delete-month-button" class="btn btn-danger" style="display: none;">Delete</button>
            </div>
        </section>

        <div id="file-operations-status" class="settings-status"></div>
    </main>

    <footer class="main-footer" role="contentinfo">
        <p>&copy; 2025 Money Tracker. All data stored locally in your browser.</p>
    </footer>

    
    
    
    
    
    
    
    
    
    
    
    
    
    
<script>
// ===== components/Header.js =====
/**
 * Shared Header Component
 * Renders consistent navigation header across all pages
 */

class Header {
    /**
     * Get the current page name from the current URL
     */
    static getCurrentPage() {
        const path = window.location.pathname;
        const filename = path.split('/').pop() || 'index.html';
        
        if (filename === 'index.html' || filename === '') {
            return 'Home';
        } else if (filename.includes('monthly-budget')) {
            return 'Monthly Budget';
        } else if (filename.includes('pots')) {
            return 'Pots & Investments';
        } else if (filename.includes('settings')) {
            return 'Settings';
        } else if (filename.includes('import')) {
            return 'Settings';
        }
        return 'Home';
    }

    /**
     * Get the base path for navigation links
     */
    static getBasePath() {
        const path = window.location.pathname;
        // If we're in the views folder, go up one level
        if (path.includes('/views/')) {
            return '../';
        }
        return '';
    }

    /**
     * Render the header HTML
     */
    static render() {
        const currentPage = this.getCurrentPage();
        const basePath = this.getBasePath();
        
        const navItems = [
            { name: 'Home', href: basePath + 'index.html', page: 'Home' },
            { name: 'Monthly Budget', href: basePath + 'views/monthly-budget.html', page: 'Monthly Budget' },
            { name: 'Pots & Investments', href: basePath + 'views/pots.html', page: 'Pots & Investments' },
            { name: 'Settings', href: basePath + 'views/settings.html', page: 'Settings' }
        ];

        const navLinks = navItems.map(item => {
            const isActive = item.page === currentPage;
            const activeClass = isActive ? ' active' : '';
            const ariaCurrent = isActive ? ' aria-current="page"' : '';
            return `<li><a href="${item.href}" class="nav-link${activeClass}"${ariaCurrent}>${item.name}</a></li>`;
        }).join('\n                ');

        return `
    <header class="main-header">
        <nav class="main-navigation" role="navigation" aria-label="Main navigation">
            <div class="header-title-group">
                <h1 class="site-title">Money Tracker</h1>
                <button class="hamburger-menu" aria-label="Toggle navigation menu" aria-expanded="false">
                    <span class="hamburger-line"></span>
                    <span class="hamburger-line"></span>
                    <span class="hamburger-line"></span>
                </button>
            </div>
            <ul class="nav-list">
                ${navLinks}
            </ul>
        </nav>
    </header>`;
    }

    /**
     * Initialize and inject header into the page
     */
    static init() {
        // Find where to insert the header (before main or body's first child)
        const main = document.querySelector('main');
        const body = document.body;
        
        if (main) {
            // Insert before main element
            main.insertAdjacentHTML('beforebegin', this.render());
        } else if (body) {
            // Insert as first child of body
            body.insertAdjacentHTML('afterbegin', this.render());
        } else {
            console.error('Header: Could not find insertion point');
            return;
        }

        // Initialize hamburger menu functionality
        this.initHamburgerMenu();
    }

    /**
     * Initialize hamburger menu functionality
     */
    static initHamburgerMenu() {
        const hamburgerBtn = document.querySelector('.hamburger-menu');
        const navList = document.querySelector('.nav-list');

        if (!hamburgerBtn || !navList) return;

        hamburgerBtn.addEventListener('click', () => {
            const isExpanded = hamburgerBtn.getAttribute('aria-expanded') === 'true';
            hamburgerBtn.setAttribute('aria-expanded', !isExpanded);
            navList.classList.toggle('nav-open');
        });

        // Close menu when clicking outside or on a link
        document.addEventListener('click', (e) => {
            if (!hamburgerBtn.contains(e.target) && !navList.contains(e.target)) {
                hamburgerBtn.setAttribute('aria-expanded', 'false');
                navList.classList.remove('nav-open');
            }
        });

        // Close menu when a link is clicked
        navList.addEventListener('click', (e) => {
            if (e.target.classList.contains('nav-link')) {
                hamburgerBtn.setAttribute('aria-expanded', 'false');
                navList.classList.remove('nav-open');
            }
        });
    }
}

// Auto-initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => Header.init());
} else {
    Header.init();
}

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = Header;
}



// ===== models/DataManager.js =====
/**
 * Data Manager Model
 * Core data operations using localStorage and file services
 * @module models/DataManager
 */

const DataManager = {
    STORAGE_KEY_MONTHS: 'money_tracker_months',
    STORAGE_KEY_POTS: 'money_tracker_pots',
    STORAGE_KEY_SETTINGS: 'money_tracker_settings',

    /**
     * Initialize default settings if they don't exist
     * @returns {Object} Settings object
     */
    initializeSettings() {
        const existingSettings = this.getSettings();
        if (!existingSettings) {
            const defaultSettings = {
                currency: '',
                defaultFixedCosts: [],
                defaultVariableCategories: ['Food', 'Travel/Transport', 'Activities'],
                defaultPots: []
            };
            this.saveSettings(defaultSettings);
            return defaultSettings;
        }
        return existingSettings;
    },

    /**
     * Get all months data from localStorage
     * @returns {Object} Object with all months keyed by monthKey
     */
    getAllMonths() {
        return window.StorageService.get(this.STORAGE_KEY_MONTHS) || {};
    },

    /**
     * Save all months data to localStorage
     * @param {Object} monthsData - Object with all months
     * @returns {boolean} Success status
     */
    saveAllMonths(monthsData) {
        return window.StorageService.set(this.STORAGE_KEY_MONTHS, monthsData);
    },

    /**
     * Get a specific month's data from localStorage
     * @param {string} monthKey - Month key (e.g., "2025-11")
     * @returns {Object|null} Month data or null
     */
    getMonth(monthKey) {
        const allMonths = this.getAllMonths();
        return allMonths[monthKey] || null;
    },

    /**
     * Save a specific month's data to localStorage and export as file
     * @param {string} monthKey - Month key
     * @param {Object} monthData - Month data object
     * @param {boolean} exportFile - Whether to export to file
     * @returns {boolean} Success status
     */
    saveMonth(monthKey, monthData, exportFile = true) {
        if (!monthKey || !monthData) {
            throw new Error('Month key and data are required');
        }

        monthData.updatedAt = new Date().toISOString();
        if (!monthData.createdAt) {
            monthData.createdAt = new Date().toISOString();
        }
        
        const allMonths = this.getAllMonths();
        allMonths[monthKey] = monthData;
        const saved = this.saveAllMonths(allMonths);
        
        if (saved && exportFile && window.ExportService) {
            window.ExportService.exportMonthToFile(monthKey, monthData, 'json').catch(error => {
                console.error('Error exporting month file:', error);
            });
        }
        
        return saved;
    },

    /**
     * Delete a month from localStorage
     * @param {string} monthKey - Month key
     * @returns {boolean} Success status
     */
    deleteMonth(monthKey) {
        const allMonths = this.getAllMonths();
        delete allMonths[monthKey];
        return this.saveAllMonths(allMonths);
    },

    /**
     * Load all months from individual JSON files into localStorage
     * @returns {Promise<Object>} Object with all months
     */
    async loadMonthsFromFiles() {
        if (!window.FileService) {
            console.error('FileService not available');
            return this.getAllMonths();
        }

        const fileMonths = await window.FileService.loadAllMonthsFromFiles();
        const localStorageMonths = this.getAllMonths();
        
        const allMonths = { ...fileMonths };
        Object.keys(localStorageMonths).forEach(key => {
            if (!allMonths[key]) {
                allMonths[key] = localStorageMonths[key];
            }
        });

        if (Object.keys(fileMonths).length > 0) {
            this.saveAllMonths(allMonths);
        }

        return allMonths;
    },

    /**
     * Load months from file picker
     * @returns {Promise<Object>} Result object
     */
    async loadMonthsFromFilePicker() {
        if (!window.FileService) {
            return { success: false, message: 'FileService not available', useFileInput: true };
        }
        return await window.FileService.loadMonthsFromFilePicker();
    },

    /**
     * Load months from file input
     * @param {FileList} files - File list
     * @returns {Promise<Object>} Result object
     */
    async loadMonthsFromFileInput(files) {
        if (!window.FileService) {
            return { success: false, count: 0, errors: files.length, months: {} };
        }
        const result = await window.FileService.loadMonthsFromFileInput(files);
        if (result.success && result.months) {
            const allMonths = this.getAllMonths();
            Object.assign(allMonths, result.months);
            this.saveAllMonths(allMonths);
        }
        return result;
    },

    /**
     * Save all months to files
     * @returns {Promise<Object>} Result object
     */
    async saveAllMonthsToFiles() {
        if (!window.ExportService) {
            return { success: false, message: 'ExportService not available' };
        }
        const allMonths = this.getAllMonths();
        return await window.ExportService.saveAllMonthsToFiles(allMonths);
    },

    /**
     * Export month to file
     * @param {string} monthKey - Month key
     * @param {Object} monthData - Month data
     * @param {string} format - Format ('json', 'csv', 'html')
     * @returns {Promise<boolean>} Success status
     */
    async exportMonthToFile(monthKey, monthData, format = 'json') {
        if (!window.ExportService) {
            console.error('ExportService not available');
            return false;
        }
        return await window.ExportService.exportMonthToFile(monthKey, monthData, format);
    },

    /**
     * Get all pots data
     * @returns {Object} Pots data object
     */
    getAllPots() {
        return window.StorageService.get(this.STORAGE_KEY_POTS) || {};
    },

    /**
     * Save all pots data
     * @param {Object} potsData - Pots data object
     * @returns {boolean} Success status
     */
    saveAllPots(potsData) {
        return window.StorageService.set(this.STORAGE_KEY_POTS, potsData);
    },

    /**
     * Get settings
     * @returns {Object|null} Settings object or null
     */
    getSettings() {
        return window.StorageService.get(this.STORAGE_KEY_SETTINGS);
    },

    /**
     * Save settings
     * @param {Object} settings - Settings object
     * @returns {boolean} Success status
     */
    saveSettings(settings) {
        return window.StorageService.set(this.STORAGE_KEY_SETTINGS, settings);
    },

    /**
     * Generate a month key from year and month
     * @param {number} year - Year
     * @param {number} month - Month (1-12)
     * @returns {string} Month key
     */
    generateMonthKey(year, month) {
        return window.MonthFactory.generateMonthKey(year, month);
    },

    /**
     * Parse month key to year and month
     * @param {string} monthKey - Month key
     * @returns {Object} Object with year and month
     */
    parseMonthKey(monthKey) {
        return window.MonthFactory.parseMonthKey(monthKey);
    },

    /**
     * Get month name from month number
     * @param {number} monthNumber - Month number (1-12)
     * @returns {string} Month name
     */
    getMonthName(monthNumber) {
        return window.MonthFactory.getMonthName(monthNumber);
    },

    /**
     * Create a new month with default structure
     * @param {number} year - Year
     * @param {number} month - Month (1-12)
     * @returns {Object} New month data object
     */
    createNewMonth(year, month) {
        const settings = this.getSettings() || this.initializeSettings();
        const newMonth = window.MonthFactory.createNewMonth(year, month, settings);
        const monthKey = newMonth.key;
        this.saveMonth(monthKey, newMonth, true);
        return newMonth;
    },

    /**
     * Calculate totals for a month
     * @param {Object} monthData - Month data object
     * @returns {Object} Totals object
     */
    calculateMonthTotals(monthData) {
        if (!window.CalculationService) {
            throw new Error('CalculationService not available');
        }
        return window.CalculationService.calculateMonthTotals(monthData);
    },

    /**
     * Generate HTML representation of month data
     * @param {Object} monthData - Month data object
     * @param {string} monthKey - Month key
     * @returns {string} HTML string
     */
    monthDataToHTML(monthData, monthKey) {
        if (!window.ExportService) {
            throw new Error('ExportService not available');
        }
        return window.ExportService.monthDataToHTML(monthData, monthKey);
    }
};

if (typeof window !== 'undefined') {
    DataManager.initializeSettings();
    window.DataManager = DataManager;
}


// ===== utils/formatters.js =====
/**
 * Utility Functions
 * Shared formatting and helper functions
 */

const Formatters = {
    /**
     * Get currency symbol from settings
     */
    getCurrencySymbol() {
        if (typeof window !== 'undefined' && window.DataManager) {
            const settings = DataManager.getSettings();
            if (settings && settings.currency) {
                return settings.currency;
            }
        }
        return ''; // Default to 
    },

    /**
     * Format currency amount
     */
    formatCurrency(amount) {
        const currencySymbol = this.getCurrencySymbol();
        return currencySymbol + parseFloat(amount || 0).toFixed(2);
    },

    /**
     * Format date for display
     */
    formatDate(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        return date.toLocaleDateString();
    },

    /**
     * Parse number safely
     */
    parseNumber(value) {
        const parsed = parseFloat(value || 0);
        return isNaN(parsed) ? 0 : parsed;
    },

    /**
     * Validate year input
     */
    validateYear(year) {
        const yearNum = parseInt(year, 10);
        return !isNaN(yearNum) && yearNum >= 2000 && yearNum <= 2100;
    },

    /**
     * Validate month input
     */
    validateMonth(month) {
        const monthNum = parseInt(month, 10);
        return !isNaN(monthNum) && monthNum >= 1 && monthNum <= 12;
    }
};

// Make available globally
if (typeof window !== 'undefined') {
    window.Formatters = Formatters;
}



// ===== utils/CSVHandler.js =====
/**
 * CSV Handler Utility
 * Handles conversion between month data and CSV format
 */

const CSVHandler = {
    /**
     * Convert month data to CSV format
     */
    monthDataToCSV(monthData) {
        const lines = [];
        
        // Header line
        lines.push('Section,Category,Field,Value,Date,Card,Paid,Description,Comments');
        
        // Weekly Breakdown
        if (monthData.weeklyBreakdown && monthData.weeklyBreakdown.length > 0) {
            monthData.weeklyBreakdown.forEach((week, index) => {
                lines.push(`Weekly Breakdown,Week ${index + 1},Date Range,"${week.dateRange || week.weekRange || ''}",,,,`);
                lines.push(`Weekly Breakdown,Week ${index + 1},Payments Due,"${(week.paymentsDue || '').replace(/"/g, '""')}",,,,`);
                lines.push(`Weekly Breakdown,Week ${index + 1},Groceries,"${(week.groceries || '').replace(/"/g, '""')}",,,,`);
                lines.push(`Weekly Breakdown,Week ${index + 1},Transport,"${(week.transport || '').replace(/"/g, '""')}",,,,`);
                lines.push(`Weekly Breakdown,Week ${index + 1},Activities,"${(week.activities || '').replace(/"/g, '""')}",,,,`);
                lines.push(`Weekly Breakdown,Week ${index + 1},Estimate,${week.estimate || week.weeklyEstimate || 0},,,,`);
                lines.push(`Weekly Breakdown,Week ${index + 1},Actual,${week.actual || 0},,,,`);
            });
        }
        
        // Income
        if (monthData.incomeSources && monthData.incomeSources.length > 0) {
            monthData.incomeSources.forEach((income, index) => {
                lines.push(`Income,${income.source || `Income ${index + 1}`},Source,"${(income.source || '').replace(/"/g, '""')}",${income.date || ''},,,"${(income.description || '').replace(/"/g, '""')}","${(income.comments || '').replace(/"/g, '""')}"`);
                lines.push(`Income,${income.source || `Income ${index + 1}`},Estimated,${income.estimated || 0},${income.date || ''},,,,"${(income.comments || '').replace(/"/g, '""')}"`);
                lines.push(`Income,${income.source || `Income ${index + 1}`},Actual,${income.actual || 0},${income.date || ''},,,,"${(income.comments || '').replace(/"/g, '""')}"`);
            });
        }
        
        // Fixed Costs
        if (monthData.fixedCosts && monthData.fixedCosts.length > 0) {
            monthData.fixedCosts.forEach((cost) => {
                lines.push(`Fixed Costs,"${(cost.category || '').replace(/"/g, '""')}",Estimated,${cost.estimatedAmount || 0},${cost.date || ''},${cost.card || ''},${cost.paid ? 'Yes' : 'No'},"","${(cost.comments || '').replace(/"/g, '""')}"`);
                lines.push(`Fixed Costs,"${(cost.category || '').replace(/"/g, '""')}",Actual,${cost.actualAmount || 0},${cost.date || ''},${cost.card || ''},${cost.paid ? 'Yes' : 'No'},"","${(cost.comments || '').replace(/"/g, '""')}"`);
            });
        }
        
        // Variable Costs
        if (monthData.variableCosts && monthData.variableCosts.length > 0) {
            monthData.variableCosts.forEach((cost) => {
                lines.push(`Variable Costs,"${(cost.category || '').replace(/"/g, '""')}",Monthly Budget,${cost.estimatedAmount || cost.monthlyBudget || 0},,,,,"${(cost.comments || '').replace(/"/g, '""')}"`);
                lines.push(`Variable Costs,"${(cost.category || '').replace(/"/g, '""')}",Actual Spent,${cost.actualAmount || cost.actualSpent || 0},,,,,"${(cost.comments || '').replace(/"/g, '""')}"`);
            });
        }
        
        // Unplanned Expenses
        if (monthData.unplannedExpenses && monthData.unplannedExpenses.length > 0) {
            monthData.unplannedExpenses.forEach((expense) => {
                lines.push(`Unplanned Expenses,"${(expense.name || '').replace(/"/g, '""')}",Amount,${expense.amount || 0},${expense.date || ''},${expense.card || ''},,${expense.status || ''},"${(expense.comments || '').replace(/"/g, '""')}"`);
            });
        }
        
        // Pots
        if (monthData.pots && monthData.pots.length > 0) {
            monthData.pots.forEach((pot) => {
                lines.push(`Pots,"${(pot.category || '').replace(/"/g, '""')}",Estimated,${pot.estimatedAmount || 0},,,,`);
                lines.push(`Pots,"${(pot.category || '').replace(/"/g, '""')}",Actual,${pot.actualAmount || 0},,,,`);
            });
        }
        
        return lines.join('\n');
    },

    /**
     * Parse CSV and convert to month data structure
     */
    csvToMonthData(csvText, monthName, year) {
        const lines = csvText.split('\n').filter(line => line.trim());
        if (lines.length < 2) {
            throw new Error('CSV file is empty or invalid');
        }
        
        // Skip header line
        const dataLines = lines.slice(1);
        
        const monthData = {
            key: `${monthName.toLowerCase()}-${year}`,
            monthName: monthName,
            year: year,
            weeklyBreakdown: [],
            income: [],
            fixedCosts: [],
            variableCosts: [],
            unplannedExpenses: [],
            pots: []
        };
        
        // Parse CSV lines
        const weeklyBreakdownMap = new Map();
        const incomeMap = new Map();
        const fixedCostsMap = new Map();
        const variableCostsMap = new Map();
        const unplannedExpensesMap = new Map();
        const potsMap = new Map();
        
        dataLines.forEach(line => {
            // Parse CSV line (handle quoted fields)
            const fields = this.parseCSVLine(line);
            if (fields.length < 4) return;
            
            const section = fields[0] || '';
            const category = fields[1] || '';
            const field = fields[2] || '';
            const value = fields[3] || '';
            const date = fields[4] || '';
            const card = fields[5] || '';
            const paid = fields[6] || '';
            const description = fields[7] || '';
            const comments = fields[8] || '';
            
            if (section === 'Weekly Breakdown') {
                const weekKey = category;
                if (!weeklyBreakdownMap.has(weekKey)) {
                    weeklyBreakdownMap.set(weekKey, {
                        dateRange: '',
                        paymentsDue: '',
                        groceries: '',
                        transport: '',
                        activities: '',
                        estimate: 0,
                        actual: 0
                    });
                }
                const week = weeklyBreakdownMap.get(weekKey);
                
                if (field === 'Date Range') week.dateRange = value;
                else if (field === 'Payments Due') week.paymentsDue = value;
                else if (field === 'Groceries') week.groceries = value;
                else if (field === 'Transport') week.transport = value;
                else if (field === 'Activities') week.activities = value;
                else if (field === 'Estimate') week.estimate = parseFloat(value) || 0;
                else if (field === 'Actual') week.actual = parseFloat(value) || 0;
            }
            else if (section === 'Income') {
                const incomeKey = category;
                if (!incomeMap.has(incomeKey)) {
                    incomeMap.set(incomeKey, {
                        source: '',
                        estimated: 0,
                        actual: 0,
                        date: '',
                        description: '',
                        comments: ''
                    });
                }
                const income = incomeMap.get(incomeKey);
                
                if (field === 'Source') income.source = value;
                else if (field === 'Estimated') income.estimated = parseFloat(value) || 0;
                else if (field === 'Actual') income.actual = parseFloat(value) || 0;
                if (date) income.date = date;
                if (description) income.description = description;
                if (comments) income.comments = comments;
            }
            else if (section === 'Fixed Costs') {
                if (!fixedCostsMap.has(category)) {
                    fixedCostsMap.set(category, {
                        category: category,
                        estimatedAmount: 0,
                        actualAmount: 0,
                        date: '',
                        card: '',
                        paid: false,
                        comments: ''
                    });
                }
                const cost = fixedCostsMap.get(category);
                
                if (field === 'Estimated') cost.estimatedAmount = parseFloat(value) || 0;
                else if (field === 'Actual') cost.actualAmount = parseFloat(value) || 0;
                if (date) cost.date = date;
                if (card) cost.card = card;
                if (paid.toLowerCase() === 'yes') cost.paid = true;
                if (comments) cost.comments = comments;
            }
            else if (section === 'Variable Costs') {
                if (!variableCostsMap.has(category)) {
                    variableCostsMap.set(category, {
                        category: category,
                        monthlyBudget: 0,
                        actualSpent: 0,
                        comments: ''
                    });
                }
                const cost = variableCostsMap.get(category);
                
                if (field === 'Monthly Budget') cost.monthlyBudget = parseFloat(value) || 0;
                else if (field === 'Actual Spent') cost.actualSpent = parseFloat(value) || 0;
                if (comments) cost.comments = comments;
            }
            else if (section === 'Unplanned Expenses') {
                if (!unplannedExpensesMap.has(category)) {
                    unplannedExpensesMap.set(category, {
                        name: category,
                        amount: 0,
                        date: '',
                        card: '',
                        status: '',
                        comments: ''
                    });
                }
                const expense = unplannedExpensesMap.get(category);
                
                if (field === 'Amount') expense.amount = parseFloat(value) || 0;
                if (date) expense.date = date;
                if (card) expense.card = card;
                if (description) expense.status = description;
                if (comments) expense.comments = comments;
            }
            else if (section === 'Pots') {
                if (!potsMap.has(category)) {
                    potsMap.set(category, {
                        category: category,
                        estimatedAmount: 0,
                        actualAmount: 0
                    });
                }
                const pot = potsMap.get(category);
                
                if (field === 'Estimated') pot.estimatedAmount = parseFloat(value) || 0;
                else if (field === 'Actual') pot.actualAmount = parseFloat(value) || 0;
            }
        });
        
        // Convert maps to arrays
        monthData.weeklyBreakdown = Array.from(weeklyBreakdownMap.values());
        // Convert to application format
        monthData.incomeSources = Array.from(incomeMap.values());
        monthData.fixedCosts = Array.from(fixedCostsMap.values());

        // Convert variable costs to use estimatedAmount/actualAmount
        monthData.variableCosts = Array.from(variableCostsMap.values()).map(cost => ({
            category: cost.category,
            estimatedAmount: cost.monthlyBudget,
            actualAmount: cost.actualSpent,
            comments: cost.comments
        }));

        monthData.unplannedExpenses = Array.from(unplannedExpensesMap.values());
        monthData.pots = Array.from(potsMap.values());
        
        return monthData;
    },

    /**
     * Parse a CSV line handling quoted fields
     */
    parseCSVLine(line) {
        const fields = [];
        let currentField = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            
            if (char === '"') {
                if (inQuotes && line[i + 1] === '"') {
                    // Escaped quote
                    currentField += '"';
                    i++;
                } else {
                    // Toggle quote state
                    inQuotes = !inQuotes;
                }
            } else if (char === ',' && !inQuotes) {
                // Field separator
                fields.push(currentField);
                currentField = '';
            } else {
                currentField += char;
            }
        }
        
        // Add last field
        fields.push(currentField);
        
        return fields;
    }
};

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CSVHandler;
}

// Make available globally
if (typeof window !== 'undefined') {
    window.CSVHandler = CSVHandler;
}


// ===== utils/ReferenceImporter.js =====
/**
 * Reference Importer Utility
 * Parses reference HTML files and imports data into the application
 */

const ReferenceImporter = {
    /**
     * Parse a reference HTML file and extract month data
     */
    parseReferenceHTML(htmlContent, monthName, year) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlContent, 'text/html');
        
        const fixedCosts = this.extractFixedCosts(doc);
        const monthData = {
            year: year,
            month: this.getMonthNumber(monthName),
            monthName: monthName,
            weeklyBreakdown: this.extractWeeklyBreakdown(doc, fixedCosts),
            income: this.extractIncome(doc),
            fixedCosts: fixedCosts,
            variableCosts: this.extractVariableCosts(doc),
            unplannedExpenses: this.extractUnplannedExpenses(doc),
            pots: this.extractPots(doc),
            dateRange: this.extractDateRange(doc, year, this.getMonthNumber(monthName))
        };

        return monthData;
    },

    /**
     * Get month number from month name
     */
    getMonthNumber(monthName) {
        const months = {
            'January': 1, 'February': 2, 'March': 3, 'April': 4,
            'May': 5, 'June': 6, 'July': 7, 'August': 8,
            'September': 9, 'October': 10, 'November': 11, 'December': 12
        };
        return months[monthName] || 1;
    },

    /**
     * Extract weekly breakdown table - the first table with Date, Payments Due, Groceries, Transport, Activities columns
     */
    extractWeeklyBreakdown(doc, fixedCosts = []) {
        const weeklyBreakdown = [];
        const tables = doc.querySelectorAll('table.simple-table');
        
        if (tables.length === 0) {
            return [];
        }

        let weeklyTable = null;
        for (let i = 0; i < tables.length; i++) {
            const table = tables[i];
            const headerRow = table.querySelector('thead tr');
            if (!headerRow) continue;

            const headers = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim());
            const hasDate = headers.some(h => h === 'Date' || h.includes('Date'));
            const hasPaymentsDue = headers.some(h => h.includes('Payments Due') || h.includes('Payments'));
            const hasGroceries = headers.some(h => h.includes('Groceries') || h.includes('Grocer'));
            const hasTransport = headers.some(h => h.includes('Transport') || h.includes('Transport'));
            const hasActivities = headers.some(h => h.includes('Activities') || h.includes('Activities'));
            const hasEstimate = headers.some(h => h.includes('Estimate') || h.includes('Est'));
            const hasActual = headers.some(h => h === 'Actual' || h.includes('Actual'));

            // This is the working section table - first table with Date, Payments Due, Groceries, Transport, Activities
            if (hasDate && hasPaymentsDue && (hasGroceries || hasTransport || hasActivities) && hasEstimate && hasActual) {
                weeklyTable = table;
                break;
            }
        }

        if (weeklyTable) {
            const rows = weeklyTable.querySelectorAll('tbody tr');

            rows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('th, td'));
                if (cells.length >= 5) {
                    const dateRange = cells[0].textContent.trim();
                    // Skip empty rows and totals row
                    if (dateRange && !dateRange.includes('TOTALS') && dateRange !== '' && !dateRange.match(/^\s*$/)) {
                        // Find column indices based on headers
                        const headerRow = weeklyTable.querySelector('thead tr');
                        const headers = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim());
                        
                        let paymentsDueIdx = -1;
                        let groceriesIdx = -1;
                        let transportIdx = -1;
                        let activitiesIdx = -1;
                        let estimateIdx = -1;
                        let actualIdx = -1;
                        let unplannedIdx = -1;
                        
                        headers.forEach((header, idx) => {
                            if (header.includes('Payments Due') || header.includes('Payments')) paymentsDueIdx = idx;
                            else if (header.includes('Unplanned')) unplannedIdx = idx;
                            else if (header.includes('Groceries') || header.includes('Grocer')) groceriesIdx = idx;
                            else if (header.includes('Transport')) transportIdx = idx;
                            else if (header.includes('Activities')) activitiesIdx = idx;
                            else if (header.includes('Estimate') || header.includes('Est')) estimateIdx = idx;
                            else if (header === 'Actual' || header.includes('Actual')) actualIdx = idx;
                        });
                        
                        // Extract data from cells
                        const paymentsDue = paymentsDueIdx >= 0 && cells[paymentsDueIdx] ? cells[paymentsDueIdx].textContent.trim() : '';
                        const groceries = groceriesIdx >= 0 && cells[groceriesIdx] ? cells[groceriesIdx].textContent.trim() : '';
                        const transport = transportIdx >= 0 && cells[transportIdx] ? cells[transportIdx].textContent.trim() : '';
                        const activities = activitiesIdx >= 0 && cells[activitiesIdx] ? cells[activitiesIdx].textContent.trim() : '';
                        const estimate = estimateIdx >= 0 && cells[estimateIdx] ? this.parseAmount(cells[estimateIdx].textContent || '') : 0;
                        const actual = actualIdx >= 0 && cells[actualIdx] ? this.parseAmount(cells[actualIdx].textContent || '') : 0;

                        weeklyBreakdown.push({
                            dateRange: dateRange,
                            weekRange: dateRange,
                            paymentsDue: paymentsDue,
                            groceries: groceries,
                            transport: transport,
                            activities: activities,
                            estimate: estimate,
                            weeklyEstimate: estimate,
                            actual: actual
                        });
                    }
                }
            });
        }

        // If no weeks found, return empty array (will be populated by user)
        return weeklyBreakdown;
    },


    /**
     * Extract date range from document
     */
    extractDateRange(doc, year, month) {
        const timeElement = doc.querySelector('time');
        if (timeElement) {
            const dateText = timeElement.textContent;
            const match = dateText.match(/(\w+)\s+(\d+),\s+(\d+)\s+\s+(\w+)\s+(\d+),\s+(\d+)/);
            if (match) {
                const startDate = new Date(year, month - 1, 1);
                const endDate = new Date(year, month, 0);
                return {
                    start: startDate.toISOString().split('T')[0],
                    end: endDate.toISOString().split('T')[0]
                };
            }
        }
        
        const startDate = new Date(year, month - 1, 1);
        const endDate = new Date(year, month, 0);
        return {
            start: startDate.toISOString().split('T')[0],
            end: endDate.toISOString().split('T')[0]
        };
    },

    /**
     * Extract income data
     */
    extractIncome(doc) {
        const income = {
            nicholasIncome: { estimated: 0, actual: 0, date: '' },
            laraIncome: { estimated: 0, actual: 0, date: '' },
            otherIncome: { estimated: 0, actual: 0, description: '' }
        };

        const tables = doc.querySelectorAll('table.simple-table');
        tables.forEach(table => {
            // Check if this is the income table (has "Revenue Source" header)
            const headerRow = table.querySelector('thead tr');
            let isIncomeTable = false;
            let estimatedIdx = 1;
            let actualIdx = 2;
            let dateIdx = 3;
            
            if (headerRow) {
                const headers = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim().toLowerCase());
                isIncomeTable = headers.some(h => h.includes('revenue') || h.includes('income'));
                if (isIncomeTable) {
                    headers.forEach((header, idx) => {
                        if (header.includes('estimate') || header.includes('estimated')) {
                            estimatedIdx = idx;
                        } else if (header.includes('actual')) {
                            actualIdx = idx;
                        } else if (header.includes('date')) {
                            dateIdx = idx;
                        }
                    });
                }
            }
            
            if (isIncomeTable) {
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 3) {
                    const source = cells[0].textContent.trim();
                        const estimated = estimatedIdx < cells.length ? this.parseAmount(cells[estimatedIdx].textContent) : 0;
                        const actual = actualIdx < cells.length ? this.parseAmount(cells[actualIdx].textContent) : 0;
                        const date = dateIdx < cells.length ? cells[dateIdx].textContent.trim() : '';

                    if (source.includes('Nicholas Income')) {
                        income.nicholasIncome.estimated = estimated;
                        income.nicholasIncome.actual = actual;
                        income.nicholasIncome.date = date;
                    } else if (source.includes('Lara Income')) {
                        income.laraIncome.estimated = estimated;
                        income.laraIncome.actual = actual;
                        income.laraIncome.date = date;
                    } else if (source.includes('Other Income')) {
                        income.otherIncome.estimated = estimated;
                        income.otherIncome.actual = actual;
                        income.otherIncome.description = source;
                    }
                }
            });
            }
        });

        return income;
    },

    /**
     * Find section heading for a table (walks backwards through DOM tree)
     */
    findSectionHeading(table, sectionName) {
        const sectionNameLower = sectionName.toLowerCase();
        const sectionNames = ['fixed costs', 'variable costs', 'unplanned', 'pots', 'investments', 'expenses vs income', 'savings and investments'];
        
        // Walk backwards through the DOM tree
        let current = table;
        let foundMatchingHeading = null;
        let depth = 0;
        const maxDepth = 50;
        
        while (current && depth < maxDepth) {
            // Check previous siblings
            let sibling = current.previousElementSibling;
            let siblingDepth = 0;
            while (sibling && siblingDepth < 20) {
                // Check if it's a heading
                const tagName = sibling.tagName ? sibling.tagName.toLowerCase() : '';
                if (tagName === 'h1' || tagName === 'h2' || tagName === 'h3') {
                    const text = (sibling.textContent || '').toLowerCase();
                    if (text.includes(sectionNameLower)) {
                        foundMatchingHeading = sibling;
                        break;
                    }
                    // Check if it's another section heading
                    for (const otherSection of sectionNames) {
                        if (otherSection !== sectionNameLower && text.includes(otherSection)) {
                            // Found another section - stop searching
                            return foundMatchingHeading !== null;
                        }
                    }
                }
                
                // Also check inside divs
                if (tagName === 'div') {
                    const headings = sibling.querySelectorAll('h1, h2, h3');
                    for (const heading of headings) {
                        const text = (heading.textContent || '').toLowerCase();
                        if (text.includes(sectionNameLower)) {
                            foundMatchingHeading = heading;
                            break;
                        }
                        for (const otherSection of sectionNames) {
                            if (otherSection !== sectionNameLower && text.includes(otherSection)) {
                                return foundMatchingHeading !== null;
                            }
                        }
                    }
                }
                
                sibling = sibling.previousElementSibling;
                siblingDepth++;
            }
            
            if (foundMatchingHeading) {
                return true;
            }
            
            // Move to parent and continue searching
            current = current.parentElement;
            depth++;
        }
        
        return false;
    },

    /**
     * Extract fixed costs
     */
    extractFixedCosts(doc) {
        const fixedCosts = [];
        const tables = doc.querySelectorAll('table.simple-table');
        
        console.log('Extracting fixed costs from ' + tables.length + ' tables');
        
        tables.forEach((table, tableIdx) => {
            // Check if this table is in the Fixed Costs section
            const isFixedCostsTable = this.findSectionHeading(table, 'Fixed Costs');
            if (!isFixedCostsTable) {
                return;
            }

            console.log('Found Fixed Costs table #' + tableIdx);

            // Get header row to determine column order
            const headerRow = table.querySelector('thead tr');
            let estimatedIdx = -1;
            let actualIdx = -1;
            let dateIdx = -1;
            let cardIdx = -1;
            
            if (headerRow) {
                const headers = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim().toLowerCase());
                console.log('Fixed Costs headers:', headers);
                headers.forEach((header, idx) => {
                    if (header.includes('estimate') || header.includes('estimated')) {
                        estimatedIdx = idx;
                    } else if (header.includes('actual')) {
                        actualIdx = idx;
                    } else if (header.includes('date')) {
                        dateIdx = idx;
                    } else if (header.includes('card')) {
                        cardIdx = idx;
                    }
                });
                console.log('Fixed Costs column indices - estimated:', estimatedIdx, 'actual:', actualIdx, 'date:', dateIdx);
            }

                const rows = table.querySelectorAll('tbody tr');
            console.log('Processing ' + rows.length + ' fixed cost rows');
            rows.forEach((row, rowIdx) => {
                    const cells = row.querySelectorAll('td');
                if (cells.length >= 2) {
                        const category = cells[0].textContent.trim();
                    if (category && !category.includes('Total') && !category.includes('Subscriptions') && category !== '' && category !== 'Category' && !category.startsWith('<')) {
                        let estimated = estimatedIdx >= 0 && estimatedIdx < cells.length ? this.parseAmount(cells[estimatedIdx].textContent) : 0;
                        let actual = actualIdx >= 0 && actualIdx < cells.length ? this.parseAmount(cells[actualIdx].textContent) : 0;
                        
                        // Handle special cases like "(Skipped for some reason)" - if estimated is 0 but actual has value, try to get estimated from actual
                        if (estimated === 0 && actual > 0 && estimatedIdx >= 0 && estimatedIdx < cells.length) {
                            const estimatedText = cells[estimatedIdx].textContent.trim();
                            if (estimatedText.includes('Skipped') || estimatedText.includes('skipped') || estimatedText === '') {
                                // Estimated is empty or skipped, keep actual value
                            }
                        }
                        const date = dateIdx >= 0 && dateIdx < cells.length ? cells[dateIdx].textContent.trim() : '';
                        const card = cardIdx >= 0 && cardIdx < cells.length ? cells[cardIdx].textContent.trim() : '';
                        const paid = (actualIdx >= 0 && actualIdx < cells.length && cells[actualIdx]?.textContent.includes('')) || 
                                   (estimatedIdx >= 0 && estimatedIdx < cells.length && cells[estimatedIdx]?.textContent.includes('')) || false;

                        if (category && (estimated > 0 || actual > 0)) {
                                fixedCosts.push({
                                    category: category,
                                    estimatedAmount: estimated,
                                    actualAmount: actual,
                                    date: date,
                                    card: card,
                                    paid: paid
                                });
                            console.log('  Added fixed cost: ' + category + ' (est: ' + estimated + ', actual: ' + actual + ')');
                            }
                        }
                    }
                });
        });

        console.log('Extracted ' + fixedCosts.length + ' fixed costs');
        return fixedCosts;
    },

    /**
     * Extract variable costs - Food, Travel/Transport, and Activities
     */
    extractVariableCosts(doc) {
        const variableCosts = [];
        const tables = doc.querySelectorAll('table.simple-table');
        
        console.log('Extracting variable costs from ' + tables.length + ' tables');
        
        tables.forEach((table, tableIdx) => {
            // Check if this table is in the Variable Costs section
            const isVariableCostsTable = this.findSectionHeading(table, 'Variable Costs');
            if (!isVariableCostsTable) {
                return;
            }

            console.log('Found Variable Costs table #' + tableIdx);

            // Get header row to determine column order
            const headerRow = table.querySelector('thead tr');
            let estimatedIdx = -1;
            let actualIdx = -1;
            
            if (headerRow) {
                const headers = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim().toLowerCase());
                console.log('Variable Costs headers:', headers);
                headers.forEach((header, idx) => {
                    if (header.includes('estimate') || header.includes('estimated') || header.includes('budget')) {
                        estimatedIdx = idx;
                    } else if (header.includes('actual')) {
                        actualIdx = idx;
                    }
                });
                console.log('Variable Costs column indices - estimated:', estimatedIdx, 'actual:', actualIdx);
            }
            
                const rows = table.querySelectorAll('tbody tr');
            console.log('Processing ' + rows.length + ' variable cost rows');
            rows.forEach((row, rowIdx) => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 2) {
                        const category = cells[0].textContent.trim();
                    if (category && !category.includes('Total') && !category.includes('Books') && category !== '' && category !== 'Category' && !category.startsWith('<')) {
                        const monthlyBudget = estimatedIdx >= 0 && estimatedIdx < cells.length ? this.parseAmount(cells[estimatedIdx].textContent) : 0;
                        const actualSpent = actualIdx >= 0 && actualIdx < cells.length ? this.parseAmount(cells[actualIdx].textContent) : 0;

                        // Normalize category names
                        let normalizedCategory = category;
                        if (category.includes('Food')) {
                            normalizedCategory = 'Food';
                        } else if (category.includes('Travel') || category.includes('Transport')) {
                            normalizedCategory = 'Travel/Transport';
                        } else if (category.includes('Activities')) {
                            normalizedCategory = 'Activities';
                        }

                        if (normalizedCategory === 'Food' || normalizedCategory === 'Travel/Transport' || normalizedCategory === 'Activities') {
                                variableCosts.push({
                                    category: normalizedCategory,
                                    estimatedAmount: monthlyBudget,
                                    actualAmount: actualSpent
                                });
                            console.log('  Added variable cost: ' + normalizedCategory + ' (budget: ' + monthlyBudget + ', actual: ' + actualSpent + ')');
                            }
                        }
                    }
                });
        });

        // Ensure we have at least Food and Activities
        const hasFood = variableCosts.some(vc => vc.category === 'Food');
        const hasActivities = variableCosts.some(vc => vc.category === 'Activities');
        
        if (!hasFood) {
            variableCosts.push({ category: 'Food', estimatedAmount: 0, actualAmount: 0 });
        }
        if (!hasActivities) {
            variableCosts.push({ category: 'Activities', estimatedAmount: 0, actualAmount: 0 });
        }

        console.log('Extracted ' + variableCosts.length + ' variable costs');
        return variableCosts;
    },

    /**
     * Extract unplanned expenses
     */
    extractUnplannedExpenses(doc) {
        const unplannedExpenses = [];
        const tables = doc.querySelectorAll('table.simple-table');
        
        console.log('Extracting unplanned expenses from ' + tables.length + ' tables');
        
        tables.forEach((table, tableIdx) => {
            // Check if this table is in the Unplanned Expenses section
            const isUnplannedTable = this.findSectionHeading(table, 'Unplanned');
            if (!isUnplannedTable) {
                return;
            }

            console.log('Found Unplanned Expenses table #' + tableIdx);

            // Get header row to determine column order (if exists)
            const headerRow = table.querySelector('thead tr');
            let nameIdx = 0;
            let amountIdx = 1;
            let dateIdx = -1;
            let cardIdx = -1;
            let statusIdx = -1;
            
            if (headerRow) {
                const headers = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim().toLowerCase());
                console.log('Unplanned Expenses headers:', headers);
                headers.forEach((header, idx) => {
                    if (header.includes('name') || header.includes('description')) {
                        nameIdx = idx;
                    } else if (header.includes('amount')) {
                        amountIdx = idx;
                    } else if (header.includes('date')) {
                        dateIdx = idx;
                    } else if (header.includes('card')) {
                        cardIdx = idx;
                    } else if (header.includes('status')) {
                        statusIdx = idx;
                    }
                });
            } else {
                // No header row - assume first column is name, second is amount
                console.log('No header row found, using default column order');
            }

                const rows = table.querySelectorAll('tbody tr');
            console.log('Processing ' + rows.length + ' unplanned expense rows');
            rows.forEach((row, rowIdx) => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 2) {
                    const name = nameIdx < cells.length ? cells[nameIdx].textContent.trim() : '';
                    if (name && !name.includes('Total') && name !== '' && !name.startsWith('<')) {
                        const amount = amountIdx < cells.length ? this.parseAmount(cells[amountIdx].textContent) : 0;
                        const date = dateIdx >= 0 && dateIdx < cells.length ? cells[dateIdx].textContent.trim() : '';
                        const card = cardIdx >= 0 && cardIdx < cells.length ? cells[cardIdx].textContent.trim() : '';
                        const status = statusIdx >= 0 && statusIdx < cells.length ? cells[statusIdx].textContent.trim() : '';

                        if (name && amount > 0) {
                                unplannedExpenses.push({
                                    name: name,
                                    amount: amount,
                                    date: date,
                                card: card,
                                status: status
                                });
                            console.log('  Added unplanned expense: ' + name + ' (' + amount + ')');
                            }
                        }
                    }
                });
        });

        console.log('Extracted ' + unplannedExpenses.length + ' unplanned expenses');
        return unplannedExpenses;
    },

    /**
     * Extract pots
     */
    extractPots(doc) {
        const pots = [];
        const tables = doc.querySelectorAll('table.simple-table');
        
        console.log('Extracting pots from ' + tables.length + ' tables');
        
        tables.forEach((table, tableIdx) => {
            // Check if this table is in the Pots/Investments section
            const isPotsTable = this.findSectionHeading(table, 'Pots') || this.findSectionHeading(table, 'Investments');
            if (!isPotsTable) {
                return;
            }

            console.log('Found Pots/Investments table #' + tableIdx);

            // Get header row to determine column order
            const headerRow = table.querySelector('thead tr');
            let categoryIdx = 0;
            let estimatedIdx = -1;
            let actualIdx = -1;
            
            if (headerRow) {
                const headers = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim().toLowerCase());
                console.log('Pots headers:', headers);
                headers.forEach((header, idx) => {
                    if (header.includes('category') || header.includes('name')) {
                        categoryIdx = idx;
                    } else if (header.includes('estimate') || header.includes('estimated')) {
                        estimatedIdx = idx;
                    } else if (header.includes('actual')) {
                        actualIdx = idx;
                    }
                });
                console.log('Pots column indices - category:', categoryIdx, 'estimated:', estimatedIdx, 'actual:', actualIdx);
            } else {
                // No header row - assume first column is category, second is estimated
                console.log('No header row found, using default column order');
            }

                const rows = table.querySelectorAll('tbody tr');
            console.log('Processing ' + rows.length + ' pot rows');
            rows.forEach((row, rowIdx) => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 2) {
                    const category = categoryIdx < cells.length ? cells[categoryIdx].textContent.trim() : '';
                    if (category && !category.includes('Total') && !category.includes('Category') && category !== '' && !category.startsWith('<')) {
                        // If no estimated column found, use first data column after category
                        const estimated = estimatedIdx >= 0 && estimatedIdx < cells.length 
                            ? this.parseAmount(cells[estimatedIdx].textContent)
                            : (cells.length > 1 ? this.parseAmount(cells[1].textContent) : 0);
                        
                        // If no actual column, use estimated value
                        const actual = actualIdx >= 0 && actualIdx < cells.length 
                            ? this.parseAmount(cells[actualIdx].textContent)
                            : estimated;

                        if (category && estimated > 0) {
                                pots.push({
                                    category: category,
                                    estimatedAmount: estimated,
                                    actualAmount: actual
                                });
                            console.log('  Added pot: ' + category + ' (estimated: ' + estimated + ', actual: ' + actual + ')');
                            }
                        }
                    }
                });
        });

        console.log('Extracted ' + pots.length + ' pots');
        return pots;
    },

    /**
     * Parse amount from text (removes currency symbols and commas)
     */
    parseAmount(text) {
        if (!text) return 0;
        // Remove currency symbols, commas, and common text patterns
        let cleaned = text.replace(/[$,\s]/g, '').trim();
        // Remove text in parentheses like "(Skipped for some reason)"
        cleaned = cleaned.replace(/\([^)]*\)/g, '').trim();
        // Remove any remaining non-numeric characters except decimal point and minus
        cleaned = cleaned.replace(/[^\d.-]/g, '').trim();
        const parsed = parseFloat(cleaned);
        return isNaN(parsed) ? 0 : parsed;
    },

    /**
     * Import a month from reference HTML file
     */
    async importMonthFromFile(file, monthName, year) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const htmlContent = e.target.result;
                    const parsedData = this.parseReferenceHTML(htmlContent, monthName, year);
                    
                    const monthKey = DataManager.generateMonthKey(year, parsedData.month);
                    
                    const monthData = {
                        key: monthKey,
                        year: parsedData.year,
                        month: parsedData.month,
                        monthName: parsedData.monthName,
                        dateRange: parsedData.dateRange,
                        weeklyBreakdown: parsedData.weeklyBreakdown || [],
                        incomeSources: this.convertIncomeToArray(parsedData.income),
                        fixedCosts: parsedData.fixedCosts || [],
                        variableCosts: parsedData.variableCosts || [
                            { category: 'Food', monthlyBudget: 0, actualSpent: 0 },
                            { category: 'Activities', monthlyBudget: 0, actualSpent: 0 }
                        ],
                        unplannedExpenses: parsedData.unplannedExpenses || [],
                        pots: parsedData.pots || [],
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };

                    // Save to localStorage and export file (files are source of truth)
                    const saved = DataManager.saveMonth(monthKey, monthData, true);
                    
                    if (saved) {
                        console.log(` Month ${monthKey} saved to localStorage`);
                        console.log(`  - Fixed Costs: ${monthData.fixedCosts.length} items`);
                        console.log(`  - Variable Costs: ${monthData.variableCosts.length} items`);
                        console.log(`  - Unplanned Expenses: ${monthData.unplannedExpenses.length} items`);
                        console.log(`  - Weekly Breakdown: ${monthData.weeklyBreakdown.length} weeks`);
                        console.log(`  - Income Sources: ${monthData.incomeSources.length} items`);
                        console.log(`  - Pots: ${monthData.pots.length} items`);
                        console.log(`  - File download should start automatically. Save it to data/months/ folder.`);
                    } else {
                        console.error(` Failed to save month ${monthKey} to localStorage`);
                    }
                    
                    resolve(monthData);
                } catch (error) {
                    reject(error);
                }
            };
            reader.onerror = reject;
            reader.readAsText(file);
        });
    },

    /**
     * Convert old income format to new array format
     */
    convertIncomeToArray(income) {
        const incomeSources = [];
        
        if (income && typeof income === 'object') {
            if (income.nicholasIncome) {
                incomeSources.push({
                    source: 'Nicholas Income',
                    estimated: income.nicholasIncome.estimated || 0,
                    actual: income.nicholasIncome.actual || 0,
                    date: income.nicholasIncome.date || '',
                    description: ''
                });
            }
            if (income.laraIncome) {
                incomeSources.push({
                    source: 'Lara Income',
                    estimated: income.laraIncome.estimated || 0,
                    actual: income.laraIncome.actual || 0,
                    date: income.laraIncome.date || '',
                    description: ''
                });
            }
            if (income.otherIncome) {
                incomeSources.push({
                    source: 'Other Income',
                    estimated: income.otherIncome.estimated || 0,
                    actual: income.otherIncome.actual || 0,
                    date: '',
                    description: income.otherIncome.description || 'e.g., sales of cloths, household'
                });
            }
        }
        
        return incomeSources;
    }
};

// Make available globally
if (typeof window !== 'undefined') {
    window.ReferenceImporter = ReferenceImporter;
}



// ===== controllers/SettingsController.js =====
/**
 * Settings Controller
 * Handles all file operations: import, export, load, delete
 * Also handles currency settings
 */

const SettingsController = {
    /**
     * Initialize the settings page
     */
    async init() {
        await DataManager.loadMonthsFromFiles();
        this.loadCurrencySetting();
        this.loadMonthSelector();
        this.setupEventListeners();
    },

    /**
     * Load and display current currency setting
     */
    loadCurrencySetting() {
        const currencySelect = document.getElementById('currency-select');
        if (!currencySelect) return;

        const settings = DataManager.getSettings();
        const currentCurrency = settings && settings.currency ? settings.currency : '';
        
        currencySelect.value = currentCurrency;
    },

    /**
     * Save currency setting
     */
    saveCurrencySetting(currency) {
        const settings = DataManager.getSettings() || DataManager.initializeSettings();
        settings.currency = currency;
        const success = DataManager.saveSettings(settings);
        
        if (success) {
            // Reload page to update all currency displays
            window.location.reload();
        }
        
        return success;
    },

    /**
     * Setup event listeners
     */
    setupEventListeners() {
        // Currency selector
        const currencySelect = document.getElementById('currency-select');
        if (currencySelect) {
            currencySelect.addEventListener('change', () => {
                const selectedCurrency = currencySelect.value;
                const currencyStatus = document.getElementById('currency-status');
                
                if (currencyStatus) {
                    currencyStatus.innerHTML = '<p style="color: var(--text-secondary);">Saving currency setting...</p>';
                }
                
                const success = this.saveCurrencySetting(selectedCurrency);
                
                if (!success && currencyStatus) {
                    currencyStatus.innerHTML = '<p style="color: var(--danger-color);">Error saving currency setting. Please try again.</p>';
                }
            });
        }

        const importButton = document.getElementById('import-button');
        const fileInput = document.getElementById('file-input');
        const exportButton = document.getElementById('export-button');
        const exportFormatSelect = document.getElementById('export-format-select');
        const monthSelector = document.getElementById('month-selector');
        const deleteMonthBtn = document.getElementById('delete-month-button');
        const importStatus = document.getElementById('import-status');
        const fileOperationsStatus = document.getElementById('file-operations-status');
        const yearInputGroup = document.getElementById('year-input-group');
        const importYear = document.getElementById('import-year');
        const clearAllDataBtn = document.getElementById('clear-all-data-button');

        // Clear all cached data button
        if (clearAllDataBtn) {
            clearAllDataBtn.addEventListener('click', () => {
                const confirmMessage = 'Are you sure you want to clear all cached data? This will remove all months, pots, and settings data stored in your browser. The original data files will not be affected, but you\'ll need to re-import them to view the data again.\n\nThis action cannot be undone.';
                if (!confirm(confirmMessage)) {
                    return;
                }

                const fileOperationsStatus = document.getElementById('file-operations-status');
                if (fileOperationsStatus) {
                    fileOperationsStatus.innerHTML = '<p style="color: var(--text-secondary);">Clearing all cached data...</p>';
                }

                try {
                    // Clear all localStorage data
                    localStorage.removeItem(DataManager.STORAGE_KEY_MONTHS);
                    localStorage.removeItem(DataManager.STORAGE_KEY_POTS);
                    localStorage.removeItem(DataManager.STORAGE_KEY_SETTINGS);

                    // Reset to default settings
                    DataManager.initializeSettings();

                    // Clear any cached data
                    DataManager._monthsCache = null;

                    // Reload month selector to show empty state
                    this.loadMonthSelector();

                    if (fileOperationsStatus) {
                        fileOperationsStatus.innerHTML = '<p style="color: var(--success-color);"> All cached data has been cleared. Settings have been reset to defaults.</p>';
                    }

                    // Optional: Reload the page to ensure clean state
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);

                } catch (error) {
                    console.error('Error clearing cached data:', error);
                    if (fileOperationsStatus) {
                        fileOperationsStatus.innerHTML = '<p style="color: var(--danger-color);">Error clearing cached data. Please try again.</p>';
                    }
                }
            });
        }

        // File input change handler - show import button and year input if needed
        if (fileInput && yearInputGroup && importYear && importButton) {
            fileInput.addEventListener('change', () => {
                const files = fileInput.files;
                if (files && files.length > 0) {
                    // Show import button when files are selected
                    importButton.style.display = 'inline-block';
                    this.handleFileInputChange(fileInput, yearInputGroup, importYear);
                } else {
                    importButton.style.display = 'none';
                    yearInputGroup.style.display = 'none';
                }
            });
        }

        // Import button handler - for manually selected files
        if (importButton && fileInput) {
            importButton.addEventListener('click', () => {
                this.handleImportFiles(fileInput, importYear, yearInputGroup, importStatus, importButton);
            });
        }


        // Export button - handles selected month or all months
        if (exportButton && exportFormatSelect && monthSelector) {
            exportButton.addEventListener('click', async () => {
                const selectedValue = monthSelector.value;
                
                if (!selectedValue) {
                    const statusElement = fileOperationsStatus || importStatus;
                    if (statusElement) {
                        statusElement.innerHTML = '<p style="color: var(--warning-color);">Please select a month to export.</p>';
                    }
                    return;
                }
                
                const format = exportFormatSelect.value || 'json';
                
                if (format === 'csv' && !window.CSVHandler) {
                    const statusElement = fileOperationsStatus || importStatus;
                    if (statusElement) {
                        statusElement.innerHTML = '<p style="color: var(--danger-color);">CSVHandler not loaded. Cannot export CSV.</p>';
                    }
                    return;
                }
                
                exportButton.disabled = true;
                const formatUpper = format.toUpperCase();
                const statusElement = fileOperationsStatus || importStatus;
                
                try {
                    if (selectedValue === 'all') {
                        // Export all months
                        const allMonths = DataManager.getAllMonths();
                        const monthKeys = Object.keys(allMonths);
                        
                        if (monthKeys.length === 0) {
                            if (statusElement) {
                                statusElement.innerHTML = '<p style="color: var(--warning-color);">No months to export.</p>';
                            }
                            return;
                        }
                        
                        if (statusElement) {
                            statusElement.innerHTML = '<p style="color: var(--text-secondary);">Exporting ' + monthKeys.length + ' months as ' + formatUpper + '...</p>';
                        }
                        
                        let exportedCount = 0;
                        for (const monthKey of monthKeys) {
                            const monthData = allMonths[monthKey];
                            const success = await DataManager.exportMonthToFile(monthKey, monthData, format);
                            if (success) exportedCount++;
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                        
                        if (statusElement) {
                            statusElement.innerHTML = '<p style="color: var(--success-color);">Successfully exported ' + exportedCount + ' months as ' + formatUpper + '!</p>';
                        }
                    } else {
                        // Export single month
                        if (statusElement) {
                            statusElement.innerHTML = '<p style="color: var(--text-secondary);">Exporting as ' + formatUpper + '...</p>';
                        }
                        
                        const monthData = DataManager.getMonth(selectedValue);
                        if (!monthData) {
                            throw new Error('Month data not found');
                        }
                        
                        const success = await DataManager.exportMonthToFile(selectedValue, monthData, format);
                        
                        if (success) {
                            const monthName = monthData.monthName || DataManager.getMonthName(monthData.month);
                            if (statusElement) {
                                statusElement.innerHTML = '<p style="color: var(--success-color);">Successfully exported ' + monthName + ' ' + monthData.year + ' as ' + formatUpper + '!</p>';
                            }
                        } else {
                            if (statusElement) {
                                statusElement.innerHTML = '<p style="color: var(--danger-color);">Failed to export month.</p>';
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error exporting:', error);
                    if (statusElement) {
                        statusElement.innerHTML = '<p style="color: var(--danger-color);">Error exporting: ' + error.message + '</p>';
                    }
                } finally {
                    exportButton.disabled = false;
                }
            });
        }

        // Delete month button
        if (deleteMonthBtn && monthSelector) {
            deleteMonthBtn.addEventListener('click', () => {
                const selectedMonthKey = monthSelector.value;
                
                if (!selectedMonthKey) {
                    alert('No month selected');
                    return;
                }
                
                const monthData = DataManager.getMonth(selectedMonthKey);
                if (!monthData) {
                    alert('Month not found');
                    return;
                }

                const monthName = monthData.monthName || DataManager.getMonthName(monthData.month);
                const year = monthData.year;

                const confirmMessage = `Are you sure you want to delete ${monthName} ${year}? This action cannot be undone.`;
                if (!confirm(confirmMessage)) {
                    return;
                }

                const success = DataManager.deleteMonth(selectedMonthKey);

                if (success) {
                    alert(`${monthName} ${year} has been deleted.`);
                    this.loadMonthSelector();
                    if (deleteMonthBtn) deleteMonthBtn.style.display = 'none';
                } else {
                    alert('Error deleting month. Please try again.');
                }
            });
        }

        // Month selector change handler - show/hide delete button (hide for "all" option)
        if (monthSelector && deleteMonthBtn) {
            monthSelector.addEventListener('change', () => {
                const selectedValue = monthSelector.value;
                const showDelete = selectedValue && selectedValue !== '' && selectedValue !== 'all';
                deleteMonthBtn.style.display = showDelete ? 'inline-block' : 'none';
            });
        }
    },

    /**
     * Handle file input change
     */
    handleFileInputChange(fileInput, yearInputGroup, importYear) {
        const files = fileInput.files;
        if (!files || files.length === 0) {
            if (yearInputGroup) yearInputGroup.style.display = 'none';
            return;
        }

        // Show year input if any selected file is CSV or HTML
        let showYearInput = false;
        for (let i = 0; i < files.length; i++) {
            const fileName = files[i].name.toLowerCase();
            if (fileName.endsWith('.csv') || fileName.endsWith('.html')) {
                showYearInput = true;
                break;
            }
        }
        if (yearInputGroup) {
            yearInputGroup.style.display = showYearInput ? 'block' : 'none';
        }

        // Try to extract year from first CSV/HTML file
        if (showYearInput && importYear) {
            for (let i = 0; i < files.length; i++) {
                const fileName = files[i].name.toLowerCase();
                if (fileName.endsWith('.csv') || fileName.endsWith('.html')) {
                    const yearMatch = fileName.match(/\b(20\d{2})\b/);
                    if (yearMatch) {
                        importYear.value = yearMatch[1];
                        break;
                    }
                }
            }
        }
    },

    /**
     * Handle import files
     */
    async handleImportFiles(fileInput, importYear, yearInputGroup, importStatus, importButton) {
        const files = fileInput.files;
        if (!files || files.length === 0) {
            if (importStatus) {
                importStatus.innerHTML = '<p style="color: var(--danger-color);">Please select at least one file.</p>';
            }
            return;
        }

        // Validate files
        let hasInvalidFile = false;
        for (let i = 0; i < files.length; i++) {
            const fileName = files[i].name.toLowerCase();
            const isJson = fileName.endsWith('.json');
            const isCsv = fileName.endsWith('.csv');
            const isHtml = fileName.endsWith('.html');

            if (!isJson && !isCsv && !isHtml) {
                hasInvalidFile = true;
                break;
            }
        }

        if (hasInvalidFile) {
            if (importStatus) {
                importStatus.innerHTML = '<p style="color: var(--danger-color);">Please select only JSON, CSV, or HTML files.</p>';
            }
            return;
        }

        // Check if year is needed and valid
        const hasCsvOrHtml = Array.from(files).some(file => {
            const fileName = file.name.toLowerCase();
            return fileName.endsWith('.csv') || fileName.endsWith('.html');
        });

        if (hasCsvOrHtml && importYear && !Formatters.validateYear(parseInt(importYear.value, 10))) {
            if (importStatus) {
                importStatus.innerHTML = '<p style="color: var(--danger-color);">Please enter a valid year for CSV/HTML files.</p>';
            }
            return;
        }

        // Check required handlers are loaded
        const hasCsv = Array.from(files).some(file => file.name.toLowerCase().endsWith('.csv'));
        const hasHtml = Array.from(files).some(file => file.name.toLowerCase().endsWith('.html'));

        if (hasCsv && !window.CSVHandler) {
            if (importStatus) {
                importStatus.innerHTML = '<p style="color: var(--danger-color);">CSVHandler not loaded. Cannot import CSV files.</p>';
            }
            return;
        }

        if (hasHtml && !window.ReferenceImporter) {
            if (importStatus) {
                importStatus.innerHTML = '<p style="color: var(--danger-color);">ReferenceImporter not loaded. Cannot import HTML files.</p>';
            }
            return;
        }

        if (importButton) importButton.disabled = true;
        if (importStatus) {
            importStatus.innerHTML = `<p>Importing ${files.length} file${files.length > 1 ? 's' : ''}...</p>`;
        }

        const year = importYear ? parseInt(importYear.value, 10) : new Date().getFullYear();
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        const results = [];
        let successCount = 0;
        let errorCount = 0;

        // Process each file
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const fileName = file.name.toLowerCase();
            const isJson = fileName.endsWith('.json');
            const isCsv = fileName.endsWith('.csv');
            const isHtml = fileName.endsWith('.html');

            try {
                let monthData = null;
                let monthName = null;
                let fileYear = year;

                // Extract month and year from filename
                for (const month of monthNames) {
                    if (fileName.includes(month.toLowerCase())) {
                        monthName = month;
                        break;
                    }
                }

                // Try to extract year from filename
                const yearMatch = fileName.match(/\b(20\d{2})\b/);
                if (yearMatch) {
                    fileYear = parseInt(yearMatch[1], 10);
                }

                // For JSON files, try to get info from file content
                if (isJson && (!monthName || !fileYear)) {
                    try {
                        const text = await file.text();
                        const jsonData = JSON.parse(text);
                        if (jsonData.monthName && jsonData.year) {
                            monthName = jsonData.monthName;
                            fileYear = jsonData.year;
                        } else if (jsonData.key) {
                            // Extract from key like "april-2025"
                            const keyParts = jsonData.key.split('-');
                            if (keyParts.length >= 2) {
                                monthName = keyParts[0].charAt(0).toUpperCase() + keyParts[0].slice(1);
                                fileYear = parseInt(keyParts[1], 10);
                            }
                        }
                    } catch (e) {
                        // Ignore parse errors, will be caught below
                    }
                }

                if (!monthName) {
                    results.push(`<p style="color: var(--warning-color);">Skipped ${file.name}: Could not determine month name</p>`);
                    errorCount++;
                    continue;
                }

                // Import based on file type
                if (isJson) {
                    const text = await file.text();
                    monthData = JSON.parse(text);
                    if (!monthData.key) {
                        monthData.key = `${monthName.toLowerCase()}-${fileYear}`;
                    }
                } else if (isCsv) {
                    const csvText = await file.text();
                    monthData = CSVHandler.csvToMonthData(csvText, monthName, fileYear);
                } else if (isHtml) {
                    monthData = await ReferenceImporter.importMonthFromFile(file, monthName, fileYear);
                }

                if (!monthData || !monthData.key) {
                    throw new Error('Could not parse month data');
                }

                // Save to DataManager
                DataManager.saveMonth(monthData.key, monthData);
                results.push(`<p style="color: var(--success-color);"> Imported ${monthName} ${fileYear}</p>`);
                successCount++;

            } catch (error) {
                results.push(`<p style="color: var(--danger-color);"> Failed to import ${file.name}: ${error.message}</p>`);
                errorCount++;
            }
        }

        // Show results
        if (importStatus) {
            if (files.length === 1 && successCount === 1) {
                const file = files[0];
                const fileName = file.name.toLowerCase();
                const isJson = fileName.endsWith('.json');
                const isCsv = fileName.endsWith('.csv');
                const isHtml = fileName.endsWith('.html');
                const fileType = isJson ? 'JSON' : (isCsv ? 'CSV' : 'HTML');

                let monthName = null;
                let fileYear = null;
                for (const month of monthNames) {
                    if (fileName.includes(month.toLowerCase())) {
                        monthName = month;
                        break;
                    }
                }
                const yearMatch = fileName.match(/\b(20\d{2})\b/);
                if (yearMatch) {
                    fileYear = yearMatch[1];
                }

                if (isJson && (!monthName || !fileYear)) {
                    try {
                        const text = await files[0].text();
                        const jsonData = JSON.parse(text);
                        if (jsonData.monthName) monthName = jsonData.monthName;
                        if (jsonData.year) fileYear = jsonData.year;
                        else if (jsonData.key) {
                            const keyParts = jsonData.key.split('-');
                            if (keyParts.length >= 2) {
                                monthName = keyParts[0].charAt(0).toUpperCase() + keyParts[0].slice(1);
                                fileYear = parseInt(keyParts[1], 10);
                            }
                        }
                    } catch (e) {}
                }

                const monthData = DataManager.getMonth(`${monthName?.toLowerCase()}-${fileYear}`);
                importStatus.innerHTML = `
                    <p style="color: var(--success-color);">
                         Successfully imported ${monthName || 'month'} ${fileYear || ''} from ${fileType} file!
                    </p>
                    ${monthData ? `<p style="margin-top: 0.5rem;"><a href="monthly-budget.html?month=${monthData.key}" style="color: var(--primary-color);">View Month </a></p>` : ''}
                `;
            } else {
                importStatus.innerHTML = `
                    <div>
                        <p><strong>Import Complete:</strong> ${successCount} succeeded, ${errorCount} failed</p>
                        ${results.join('')}
                        ${successCount > 0 ? `<p><a href="monthly-budget.html" style="color: var(--primary-color);">View Monthly Budget</a></p>` : ''}
                    </div>
                `;
            }
        }

        if (fileInput) fileInput.value = '';
        if (yearInputGroup) yearInputGroup.style.display = 'none';
        if (importButton) {
            importButton.disabled = false;
            importButton.style.display = 'none';
        }
        this.loadMonthSelector();
    },

    /**
     * Load month selector dropdown
     */
    loadMonthSelector() {
        const selector = document.getElementById('month-selector');
        if (!selector) return;

        const allMonths = DataManager.getAllMonths();
        const monthKeys = Object.keys(allMonths).sort().reverse();

        if (monthKeys.length > 0) {
            selector.innerHTML = '<option value="">Select month...</option>' +
                '<option value="all">Export All Months</option>' + 
                monthKeys.map(key => {
                    const monthData = allMonths[key];
                    const monthName = monthData.monthName || DataManager.getMonthName(monthData.month);
                    return `<option value="${key}">${monthName} ${monthData.year}</option>`;
                }).join('');
        } else {
            selector.innerHTML = '<option value="">No months available</option>';
        }
    }
};

// Make available globally
window.SettingsController = SettingsController;




// ===== Inline Scripts =====

// Inline script 1

        // Initialize settings
        DataManager.initializeSettings();
        
        // Initialize SettingsController when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            SettingsController.init();
        });
    
</script>
</body>
</html>
